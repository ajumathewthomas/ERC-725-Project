/**
 * Options argument can be used to specify advanced configuration.
 */
export type CreateOptions<Init extends boolean | import("./components/init").InitOptions, Start extends boolean> = {
    repo?: RepoOption;
    /**
     * - `js-ipfs` comes bundled with a
     * tool that automatically migrates your IPFS repository when a new version is
     * available.
     */
    repoAutoMigrate?: boolean | undefined;
    /**
     * - Perform repo initialization steps when creating
     * the IPFS node.
     * Note that *initializing* a repo is different from creating an instance of
     * [`ipfs.Repo`](https://github.com/ipfs/js-ipfs-repo). The IPFS constructor
     * sets many special properties when initializing a repo, so you should usually
     * not try and call `repoInstance.init()` yourself.
     */
    init?: Init | undefined;
    /**
     * - If `false`, do not automatically
     * start the IPFS node. Instead, you’ll need to manually call
     * [`node.start()`](https://github.com/ipfs/js-ipfs/blob/master/packages/ipfs/docs/MODULE.md#nodestart)
     * yourself.
     */
    start?: Start | undefined;
    /**
     * - A passphrase to encrypt/decrypt your keys.
     */
    pass?: string | undefined;
    /**
     * - Prevents all logging output from the
     * IPFS node. (Default: `false`)
     */
    silent?: boolean | undefined;
    /**
     * - Configure circuit relay (see the [circuit relay tutorial]
     * (https://github.com/ipfs/js-ipfs/tree/master/examples/circuit-relaying)
     * to learn more).
     */
    relay?: RelayOptions | undefined;
    /**
     * - Run ipfs node offline. The node does
     * not connect to the rest of the network but provides a local API.
     */
    offline?: boolean | undefined;
    /**
     * - Configure remote preload nodes.
     * The remote will preload content added on this node, and also attempt to
     * preload objects requested by this node.
     */
    preload?: PreloadOptions | undefined;
    /**
     * - Enable and configure
     * experimental features.
     */
    EXPERIMENTAL?: ExperimentalOptions | undefined;
    /**
     * - Modify the default IPFS node config. This
     * object will be *merged* with the default config; it will not replace it.
     * (Default: [`config-nodejs.js`](https://github.com/ipfs/js-ipfs/tree/master/packages/ipfs/src/core/runtime/config-nodejs.js)
     * in Node.js, [`config-browser.js`](https://github.com/ipfs/js-ipfs/tree/master/packages/ipfs/src/core/runtime/config-browser.js)
     * in browsers)
     */
    config?: object;
    /**
     * - Modify the default IPLD config. This object
     * will be *merged* with the default config; it will not replace it. Check IPLD
     * [docs](https://github.com/ipld/js-ipld#ipld-constructor) for more information
     * on the available options. (Default: [`ipld.js`]
     * (https://github.com/ipfs/js-ipfs/tree/master/packages/ipfs/src/core/runtime/ipld.js)
     * in browsers)
     */
    ipld?: any;
    /**
     * - The libp2p option allows you to build
     * your libp2p node by configuration, or via a bundle function. If you are
     * looking to just modify the below options, using the object format is the
     * quickest way to get the default features of libp2p. If you need to create a
     * more customized libp2p node, such as with custom transports or peer/content
     * routers that need some of the ipfs data on startup, a custom bundle is a
     * great way to achieve this.
     * - You can see the bundle in action in the [custom libp2p example](https://github.com/ipfs/js-ipfs/tree/master/examples/custom-libp2p).
     * - Please see [libp2p/docs/CONFIGURATION.md](https://github.com/libp2p/js-libp2p/blob/master/doc/CONFIGURATION.md)
     * for the list of options libp2p supports.
     * - Default: [`libp2p-nodejs.js`](../src/core/runtime/libp2p-nodejs.js)
     * in Node.js, [`libp2p-browser.js`](../src/core/runtime/libp2p-browser.js) in
     * browsers.
     */
    libp2p?: object | Function;
};
/**
 * The file path at which to store the IPFS node’s data. Alternatively, you
 * can set up a customized storage system by providing an `ipfs.Repo` instance.
 */
export type RepoOption = any;
export type InitOptions = {
    /**
     * - Whether to remove built-in assets,
     * like the instructional tour and empty mutable file system, from the repo.
     */
    emptyRepo?: boolean | undefined;
    /**
     * - Number of bits to use in the generated key
     * pair (rsa only).
     */
    bits?: number | undefined;
    /**
     * - A pre-generated private key to use.
     * **NOTE: This overrides `bits`.**
     */
    privateKey?: string | import("peer-id") | undefined;
    /**
     * - A passphrase to encrypt keys. You should
     * generally use the top-level `pass` option instead of the `init.pass`
     * option (this one will take its value from the top-level option if not set).
     */
    pass?: string | undefined;
    /**
     * - Apply profile settings to config.
     */
    profiles?: string[] | undefined;
    /**
     * - Set to `false` to disallow
     * initialization if the repo does not already exist.
     */
    allowNew?: boolean | undefined;
    config?: import("./components/config").IPFSConfig | undefined;
};
export type RelayOptions = {
    /**
     * - Enable circuit relay dialer and listener. (Default: `true`)
     */
    enabled?: boolean | undefined;
    hop?: {
        /**
         * - Make this node a relay (other nodes can connect *through* it). (Default: `false`)
         */
        enabled?: boolean | undefined;
        /**
         * - Make this an *active* relay node. Active relay nodes will attempt to dial a destination peer even if that peer is not yet connected to the relay. (Default: `false`)
         */
        active?: boolean | undefined;
    } | undefined;
};
export type PreloadOptions = {
    /**
     * - Enable content preloading (Default: `true`)
     */
    enabled?: boolean | undefined;
    /**
     * - Multiaddr API addresses of nodes that should preload content.
     * **NOTE:** nodes specified here should also be added to your node's bootstrap address list at `config.Boostrap`.
     */
    addresses?: string[] | undefined;
};
export type ExperimentalOptions = {
    /**
     * - Enable pub-sub on IPNS. (Default: `false`)
     */
    ipnsPubsub?: boolean | undefined;
    /**
     * - Enable directory sharding. Directories that have many child objects will be represented by multiple DAG nodes instead of just one. It can improve lookup performance when a directory has several thousand files or more. (Default: `false`)
     */
    sharding?: boolean | undefined;
};
export type IPFSRepo = any;
/**
 * Utility type to write type level conditionals
 */
export type If<Conditon, Then, Else> = NonNullable<Conditon> extends false ? Else : Then;
/**
 * Creates and returns a ready to use instance of an IPFS node.
 *
 * @template {boolean | InitOptions} Init
 * @template {boolean} Start
 * @param {CreateOptions<Init, Start>} [options]
 */
export function create<Init extends boolean | import("./components/init").InitOptions, Start extends boolean>(options?: CreateOptions<Init, Start> | undefined): Promise<NonNullable<Init> extends false ? {
    init: (options?: any) => Promise<{
        add: any;
        addAll: any;
        bitswap: {
            stat: () => Promise<never>;
            unwant: () => Promise<never>;
            wantlist: () => Promise<never>;
            wantlistForPeer: () => Promise<never>;
        };
        bootstrap: {
            add: (multiaddr: import("multiaddr"), options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/bootstrap/utils").Peers>;
            list: (options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/bootstrap/utils").Peers>;
            rm: (multiaddr: import("multiaddr"), options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/bootstrap/utils").Peers>;
        };
        block: any;
        cat: (ipfsPath: string | import("cids"), options?: (import("./components/cat").CatOptions & import("./utils").AbortOptions) | undefined) => AsyncIterable<Uint8Array>;
        config: import("./components/config").Config;
        dag: any;
        dns: (domain: string, options?: (import("./components/dns").DNSSettings & import("./utils").AbortOptions) | undefined) => Promise<string>;
        files: import("./components/files").MFS;
        get: (ipfsPath: string | import("cids"), options?: (import("./components/get").GetOptions & import("./utils").AbortOptions) | undefined) => AsyncIterable<import("./utils").File | import("./utils").Directory>;
        id: (_options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/id").PeerId>;
        init: () => Promise<never>;
        isOnline: () => boolean;
        key: {
            export: (name?: any, password?: any, options?: any) => any;
            gen: (name?: any, options?: any) => any;
            import: (name?: any, pem?: any, password?: any, options?: any) => any;
            info: (name?: any, options?: any) => any;
            list: (options?: any) => any;
            rename: (oldName?: any, newName?: any, options?: any) => Promise<{
                was: any;
                now: any;
                id: any;
                overwrite: boolean;
            }>;
            rm: (name?: any, options?: any) => any;
        };
        ls: (ipfsPath: string | import("cids"), options?: (import("./components/ls").LSOptions & import("./utils").AbortOptions) | undefined) => AsyncIterable<import("./utils").File | import("./utils").Directory>;
        object: any;
        pin: any;
        refs: ((ipfsPath?: any, options?: any) => AsyncGenerator<{
            ref: any;
        }, void, unknown>) & {
            local: (options?: any) => AsyncGenerator<{
                ref: any;
            }, void, any>;
        };
        repo: {
            gc: (_options?: import("./utils").AbortOptions | undefined) => AsyncIterable<import("./components/repo/gc").Err | import("./components/repo/gc").BlockID>;
            stat: (options?: any) => Promise<{
                numObjects: any;
                repoSize: any;
                repoPath: any;
                version: any;
                storageMax: any;
            }>;
            version: (options?: any) => Promise<any>;
        };
        resolve: (path: string, opts?: (import("./components/resolve").ResolveSettings & import("./utils").AbortOptions) | undefined) => Promise<string>;
        start: () => Promise<{
            add: (source: import("ipfs-core-utils/src/files/normalise-input/normalise-input").FileInput, options?: (import("./components/add").AddOptions & import("./utils").AbortOptions) | undefined) => Promise<import("./components/add-all").UnixFSEntry>; /**
             * Utility type to write type level conditionals
             *
             * @template Conditon, Then, Else
             * @typedef {NonNullable<Conditon> extends false ? Else : Then } If
             */
            addAll: (source: import("ipfs-core-utils/src/files/normalise-input/normalise-input").Source, options?: (import("./components/add-all").AddAllOptions & import("./utils").AbortOptions) | undefined) => AsyncIterable<import("./components/add-all").UnixFSEntry>;
            bitswap: {
                stat: (_options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/bitswap/stat").BitswapStats>;
                unwant: (cids: import("cids") | import("cids")[], options?: import("./utils").AbortOptions | undefined) => Promise<void>;
                wantlist: (options?: import("./utils").AbortOptions | undefined) => Promise<import("cids")[]>;
                wantlistForPeer: (peerId: string | import("cids") | Uint8Array | import("peer-id"), options?: import("./utils").AbortOptions | undefined) => Promise<import("cids")[]>;
            };
            block: import("./components").Block;
            bootstrap: {
                add: (multiaddr: import("multiaddr"), options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/bootstrap/utils").Peers>;
                clear: (options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/bootstrap/utils").Peers>;
                list: (options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/bootstrap/utils").Peers>;
                reset: (options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/bootstrap/utils").Peers>;
                rm: (multiaddr: import("multiaddr"), options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/bootstrap/utils").Peers>;
            };
            cat: (ipfsPath: string | import("cids"), options?: (import("./components/cat").CatOptions & import("./utils").AbortOptions) | undefined) => AsyncIterable<Uint8Array>;
            config: import("./components/config").Config;
            dag: import("./components").DAG;
            dht: {
                get: (key: string | Uint8Array, options?: import("./utils").AbortOptions | undefined) => Promise<Uint8Array>;
                put: (key: Uint8Array, value: Uint8Array, options?: import("./utils").AbortOptions | undefined) => AsyncIterable<import("./components/dht").QueryEvent>;
                findProvs: (cid: import("cids"), options?: (import("./components/dht").FindProvsOptions & import("./utils").AbortOptions) | undefined) => AsyncIterable<import("./components/dht").PeerInfo>;
                findPeer: (peerId: import("cids") | import("peer-id"), options?: import("./utils").AbortOptions | undefined) => Promise<{
                    id: string;
                    addrs: import("multiaddr")[];
                }>;
                provide: (cids: import("cids") | import("cids")[], options?: (import("./components/dht").ProvideOptions & import("./utils").AbortOptions) | undefined) => AsyncIterable<import("./components/dht").QueryEvent>;
                query: (peerId: string | import("peer-id"), options?: import("./utils").AbortOptions | undefined) => AsyncIterable<{
                    id: import("cids");
                    addrs: import("multiaddr")[];
                }>;
            } | {
                get: () => Promise<never>;
                put: () => Promise<never>;
                findProvs: () => AsyncGenerator<never, never, unknown>;
                findPeer: () => Promise<never>;
                provide: () => AsyncGenerator<never, never, unknown>;
                query: () => AsyncGenerator<never, never, unknown>;
            };
            dns: (domain: string, options?: (import("./components/dns").DNSSettings & import("./utils").AbortOptions) | undefined) => Promise<string>;
            files: import("./components/files").MFS | undefined;
            get: (ipfsPath: string | import("cids"), options?: (import("./components/get").GetOptions & import("./utils").AbortOptions) | undefined) => AsyncIterable<import("./utils").File | import("./utils").Directory>;
            id: (_options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/id").PeerId>;
            init: () => Promise<never>;
            isOnline: () => boolean;
            ipld: typeof import("./components");
            key: {
                export: (name?: any, password?: any, options?: any) => any;
                gen: (name?: any, options?: any) => any;
                import: (name?: any, pem?: any, password?: any, options?: any) => any;
                info: (name?: any, options?: any) => any;
                list: (options?: any) => any;
                rename: (oldName?: any, newName?: any, options?: any) => Promise<{
                    was: any;
                    now: any;
                    id: any;
                    overwrite: boolean;
                }>;
                rm: (name?: any, options?: any) => any;
            };
            libp2p: any;
            ls: (ipfsPath: string | import("cids"), options?: (import("./components/ls").LSOptions & import("./utils").AbortOptions) | undefined) => AsyncIterable<import("./utils").File | import("./utils").Directory>;
            name: {
                pubsub: {
                    cancel: (name: string, options?: import("./utils").AbortOptions | undefined) => Promise<{
                        canceled: boolean;
                    }>;
                    state: (_options?: import("./utils").AbortOptions | undefined) => Promise<{
                        enabled: boolean;
                    }>;
                    subs: (options?: import("./utils").AbortOptions | undefined) => Promise<string[]>;
                };
                publish: (value: string, options?: (import("./components/name/publish").PublishSettings & import("./utils").AbortOptions) | undefined) => Promise<import("./components/name/publish").PublishResult>;
                resolve: (name: string, options?: (import("./components/name/resolve").ResolveSettings & import("./utils").AbortOptions) | undefined) => AsyncIterable<string>;
            };
            object: {
                data: (multihash?: any, options?: any) => Promise<any>;
                get: (multihash?: any, options?: any) => Promise<any>;
                links: (multihash?: any, options?: any) => Promise<any>;
                new: (options?: any) => Promise<any>;
                patch: {
                    addLink: (multihash?: any, link?: any, options?: any) => Promise<any>;
                    appendData: (multihash?: any, data?: any, options?: any) => Promise<any>;
                    rmLink: (multihash?: any, linkRef?: any, options?: any) => Promise<any>;
                    setData: (multihash?: any, data?: any, options?: any) => Promise<any>;
                };
                put: (obj?: any, options?: any) => Promise<any>;
                stat: (multihash?: any, options?: any) => Promise<{
                    Hash: any;
                    NumLinks: any;
                    BlockSize: any;
                    LinksSize: number;
                    DataSize: any;
                    CumulativeSize: any;
                }>;
            };
            pin: import("./components").Pin;
            ping: (peerId: import("peer-id"), options?: (import("./components/ping").PingSettings & import("./utils").AbortOptions) | undefined) => AsyncIterable<import("./components/ping").Pong | import("./components/ping").PingFailure | import("./components/ping").StatusUpdate>;
            pubsub: {
                subscribe: (...args: any[]) => any;
                unsubscribe: (...args: any[]) => any;
                publish: (topic?: any, data?: any, _options?: any) => Promise<void>;
                ls: (...args: any[]) => any;
                peers: (...args: any[]) => any;
            };
            refs: ((ipfsPath?: any, options?: any) => AsyncGenerator<{
                ref: any;
            }, void, unknown>) & {
                local: (options?: any) => AsyncGenerator<{
                    ref: any;
                }, void, any>;
            };
            repo: {
                gc: (_options?: import("./utils").AbortOptions | undefined) => AsyncIterable<import("./components/repo/gc").Err | import("./components/repo/gc").BlockID>;
                stat: (options?: any) => Promise<{
                    numObjects: any;
                    repoSize: any;
                    repoPath: any;
                    version: any;
                    storageMax: any;
                }>;
                version: (options?: any) => Promise<any>;
            };
            resolve: (path: string, opts?: (import("./components/resolve").ResolveSettings & import("./utils").AbortOptions) | undefined) => Promise<string>;
            start: () => {};
            stats: {
                bitswap: (_options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/bitswap/stat").BitswapStats>;
                bw: ((options?: any) => AsyncGenerator<{
                    totalIn: any;
                    totalOut: any;
                    rateIn: import("bignumber.js").default;
                    rateOut: import("bignumber.js").default;
                }, void, any>) | (() => Promise<never>);
                repo: (options?: any) => Promise<{
                    numObjects: any;
                    repoSize: any;
                    repoPath: any;
                    version: any;
                    storageMax: any;
                }>;
            };
            stop: (_options: import("./utils").AbortOptions) => Promise<void>;
            swarm: {
                addrs: (options?: any) => Promise<{
                    id: any;
                    addrs: any;
                }[]>;
                connect: (addr?: any, options?: any) => any;
                disconnect: (addr?: any, options?: any) => any;
                localAddrs: () => Promise<any>;
                peers: (options?: any) => Promise<{
                    addr: any;
                    peer: any;
                }[]>;
            };
            version: (options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/version").Version>;
        }>;
        stats: {
            bitswap: () => Promise<never>;
            bw: () => Promise<never>;
            repo: (options?: any) => Promise<{
                numObjects: any;
                repoSize: any;
                repoPath: any;
                version: any;
                storageMax: any;
            }>;
        };
        stop: () => void;
        swarm: {
            addrs: () => Promise<never>;
            connect: () => Promise<never>;
            disconnect: () => Promise<never>;
            localAddrs: () => Promise<any>;
            peers: () => Promise<never>;
        };
        version: (options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/version").Version>;
    }>;
    dns: (domain: string, options?: (import("./components/dns").DNSSettings & import("./utils").AbortOptions) | undefined) => Promise<string>;
    isOnline: () => boolean;
} : NonNullable<Start> extends false ? {
    add: any;
    addAll: any;
    bitswap: {
        stat: () => Promise<never>;
        unwant: () => Promise<never>;
        wantlist: () => Promise<never>;
        wantlistForPeer: () => Promise<never>;
    };
    bootstrap: {
        add: (multiaddr: import("multiaddr"), options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/bootstrap/utils").Peers>;
        list: (options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/bootstrap/utils").Peers>;
        rm: (multiaddr: import("multiaddr"), options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/bootstrap/utils").Peers>;
    };
    block: any;
    cat: (ipfsPath: string | import("cids"), options?: (import("./components/cat").CatOptions & import("./utils").AbortOptions) | undefined) => AsyncIterable<Uint8Array>;
    config: import("./components/config").Config;
    dag: any;
    dns: (domain: string, options?: (import("./components/dns").DNSSettings & import("./utils").AbortOptions) | undefined) => Promise<string>;
    files: import("./components/files").MFS;
    get: (ipfsPath: string | import("cids"), options?: (import("./components/get").GetOptions & import("./utils").AbortOptions) | undefined) => AsyncIterable<import("./utils").File | import("./utils").Directory>;
    id: (_options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/id").PeerId>;
    init: () => Promise<never>;
    isOnline: () => boolean;
    key: {
        export: (name?: any, password?: any, options?: any) => any;
        gen: (name?: any, options?: any) => any;
        import: (name?: any, pem?: any, password?: any, options?: any) => any;
        info: (name?: any, options?: any) => any;
        list: (options?: any) => any;
        rename: (oldName?: any, newName?: any, options?: any) => Promise<{
            was: any;
            now: any;
            id: any;
            overwrite: boolean;
        }>;
        rm: (name?: any, options?: any) => any;
    };
    ls: (ipfsPath: string | import("cids"), options?: (import("./components/ls").LSOptions & import("./utils").AbortOptions) | undefined) => AsyncIterable<import("./utils").File | import("./utils").Directory>;
    object: any;
    pin: any;
    refs: ((ipfsPath?: any, options?: any) => AsyncGenerator<{
        ref: any;
    }, void, unknown>) & {
        local: (options?: any) => AsyncGenerator<{
            ref: any;
        }, void, any>;
    };
    repo: {
        gc: (_options?: import("./utils").AbortOptions | undefined) => AsyncIterable<import("./components/repo/gc").Err | import("./components/repo/gc").BlockID>;
        stat: (options?: any) => Promise<{
            numObjects: any;
            repoSize: any;
            repoPath: any;
            version: any;
            storageMax: any;
        }>;
        version: (options?: any) => Promise<any>;
    };
    resolve: (path: string, opts?: (import("./components/resolve").ResolveSettings & import("./utils").AbortOptions) | undefined) => Promise<string>;
    start: () => Promise<{
        add: (source: import("ipfs-core-utils/src/files/normalise-input/normalise-input").FileInput, options?: (import("./components/add").AddOptions & import("./utils").AbortOptions) | undefined) => Promise<import("./components/add-all").UnixFSEntry>; /**
         * Utility type to write type level conditionals
         *
         * @template Conditon, Then, Else
         * @typedef {NonNullable<Conditon> extends false ? Else : Then } If
         */
        addAll: (source: import("ipfs-core-utils/src/files/normalise-input/normalise-input").Source, options?: (import("./components/add-all").AddAllOptions & import("./utils").AbortOptions) | undefined) => AsyncIterable<import("./components/add-all").UnixFSEntry>;
        bitswap: {
            stat: (_options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/bitswap/stat").BitswapStats>;
            unwant: (cids: import("cids") | import("cids")[], options?: import("./utils").AbortOptions | undefined) => Promise<void>;
            wantlist: (options?: import("./utils").AbortOptions | undefined) => Promise<import("cids")[]>;
            wantlistForPeer: (peerId: string | import("cids") | Uint8Array | import("peer-id"), options?: import("./utils").AbortOptions | undefined) => Promise<import("cids")[]>;
        };
        block: import("./components").Block;
        bootstrap: {
            add: (multiaddr: import("multiaddr"), options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/bootstrap/utils").Peers>;
            clear: (options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/bootstrap/utils").Peers>;
            list: (options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/bootstrap/utils").Peers>;
            reset: (options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/bootstrap/utils").Peers>;
            rm: (multiaddr: import("multiaddr"), options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/bootstrap/utils").Peers>;
        };
        cat: (ipfsPath: string | import("cids"), options?: (import("./components/cat").CatOptions & import("./utils").AbortOptions) | undefined) => AsyncIterable<Uint8Array>;
        config: import("./components/config").Config;
        dag: import("./components").DAG;
        dht: {
            get: (key: string | Uint8Array, options?: import("./utils").AbortOptions | undefined) => Promise<Uint8Array>;
            put: (key: Uint8Array, value: Uint8Array, options?: import("./utils").AbortOptions | undefined) => AsyncIterable<import("./components/dht").QueryEvent>;
            findProvs: (cid: import("cids"), options?: (import("./components/dht").FindProvsOptions & import("./utils").AbortOptions) | undefined) => AsyncIterable<import("./components/dht").PeerInfo>;
            findPeer: (peerId: import("cids") | import("peer-id"), options?: import("./utils").AbortOptions | undefined) => Promise<{
                id: string;
                addrs: import("multiaddr")[];
            }>;
            provide: (cids: import("cids") | import("cids")[], options?: (import("./components/dht").ProvideOptions & import("./utils").AbortOptions) | undefined) => AsyncIterable<import("./components/dht").QueryEvent>;
            query: (peerId: string | import("peer-id"), options?: import("./utils").AbortOptions | undefined) => AsyncIterable<{
                id: import("cids");
                addrs: import("multiaddr")[];
            }>;
        } | {
            get: () => Promise<never>;
            put: () => Promise<never>;
            findProvs: () => AsyncGenerator<never, never, unknown>;
            findPeer: () => Promise<never>;
            provide: () => AsyncGenerator<never, never, unknown>;
            query: () => AsyncGenerator<never, never, unknown>;
        };
        dns: (domain: string, options?: (import("./components/dns").DNSSettings & import("./utils").AbortOptions) | undefined) => Promise<string>;
        files: import("./components/files").MFS | undefined;
        get: (ipfsPath: string | import("cids"), options?: (import("./components/get").GetOptions & import("./utils").AbortOptions) | undefined) => AsyncIterable<import("./utils").File | import("./utils").Directory>;
        id: (_options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/id").PeerId>;
        init: () => Promise<never>;
        isOnline: () => boolean;
        ipld: typeof import("./components");
        key: {
            export: (name?: any, password?: any, options?: any) => any;
            gen: (name?: any, options?: any) => any;
            import: (name?: any, pem?: any, password?: any, options?: any) => any;
            info: (name?: any, options?: any) => any;
            list: (options?: any) => any;
            rename: (oldName?: any, newName?: any, options?: any) => Promise<{
                was: any;
                now: any;
                id: any;
                overwrite: boolean;
            }>;
            rm: (name?: any, options?: any) => any;
        };
        libp2p: any;
        ls: (ipfsPath: string | import("cids"), options?: (import("./components/ls").LSOptions & import("./utils").AbortOptions) | undefined) => AsyncIterable<import("./utils").File | import("./utils").Directory>;
        name: {
            pubsub: {
                cancel: (name: string, options?: import("./utils").AbortOptions | undefined) => Promise<{
                    canceled: boolean;
                }>;
                state: (_options?: import("./utils").AbortOptions | undefined) => Promise<{
                    enabled: boolean;
                }>;
                subs: (options?: import("./utils").AbortOptions | undefined) => Promise<string[]>;
            };
            publish: (value: string, options?: (import("./components/name/publish").PublishSettings & import("./utils").AbortOptions) | undefined) => Promise<import("./components/name/publish").PublishResult>;
            resolve: (name: string, options?: (import("./components/name/resolve").ResolveSettings & import("./utils").AbortOptions) | undefined) => AsyncIterable<string>;
        };
        object: {
            data: (multihash?: any, options?: any) => Promise<any>;
            get: (multihash?: any, options?: any) => Promise<any>;
            links: (multihash?: any, options?: any) => Promise<any>;
            new: (options?: any) => Promise<any>;
            patch: {
                addLink: (multihash?: any, link?: any, options?: any) => Promise<any>;
                appendData: (multihash?: any, data?: any, options?: any) => Promise<any>;
                rmLink: (multihash?: any, linkRef?: any, options?: any) => Promise<any>;
                setData: (multihash?: any, data?: any, options?: any) => Promise<any>;
            };
            put: (obj?: any, options?: any) => Promise<any>;
            stat: (multihash?: any, options?: any) => Promise<{
                Hash: any;
                NumLinks: any;
                BlockSize: any;
                LinksSize: number;
                DataSize: any;
                CumulativeSize: any;
            }>;
        };
        pin: import("./components").Pin;
        ping: (peerId: import("peer-id"), options?: (import("./components/ping").PingSettings & import("./utils").AbortOptions) | undefined) => AsyncIterable<import("./components/ping").Pong | import("./components/ping").PingFailure | import("./components/ping").StatusUpdate>;
        pubsub: {
            subscribe: (...args: any[]) => any;
            unsubscribe: (...args: any[]) => any;
            publish: (topic?: any, data?: any, _options?: any) => Promise<void>;
            ls: (...args: any[]) => any;
            peers: (...args: any[]) => any;
        };
        refs: ((ipfsPath?: any, options?: any) => AsyncGenerator<{
            ref: any;
        }, void, unknown>) & {
            local: (options?: any) => AsyncGenerator<{
                ref: any;
            }, void, any>;
        };
        repo: {
            gc: (_options?: import("./utils").AbortOptions | undefined) => AsyncIterable<import("./components/repo/gc").Err | import("./components/repo/gc").BlockID>;
            stat: (options?: any) => Promise<{
                numObjects: any;
                repoSize: any;
                repoPath: any;
                version: any;
                storageMax: any;
            }>;
            version: (options?: any) => Promise<any>;
        };
        resolve: (path: string, opts?: (import("./components/resolve").ResolveSettings & import("./utils").AbortOptions) | undefined) => Promise<string>;
        start: () => {};
        stats: {
            bitswap: (_options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/bitswap/stat").BitswapStats>;
            bw: ((options?: any) => AsyncGenerator<{
                totalIn: any;
                totalOut: any;
                rateIn: import("bignumber.js").default;
                rateOut: import("bignumber.js").default;
            }, void, any>) | (() => Promise<never>);
            repo: (options?: any) => Promise<{
                numObjects: any;
                repoSize: any;
                repoPath: any;
                version: any;
                storageMax: any;
            }>;
        };
        stop: (_options: import("./utils").AbortOptions) => Promise<void>;
        swarm: {
            addrs: (options?: any) => Promise<{
                id: any;
                addrs: any;
            }[]>;
            connect: (addr?: any, options?: any) => any;
            disconnect: (addr?: any, options?: any) => any;
            localAddrs: () => Promise<any>;
            peers: (options?: any) => Promise<{
                addr: any;
                peer: any;
            }[]>;
        };
        version: (options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/version").Version>;
    }>;
    stats: {
        bitswap: () => Promise<never>;
        bw: () => Promise<never>;
        repo: (options?: any) => Promise<{
            numObjects: any;
            repoSize: any;
            repoPath: any;
            version: any;
            storageMax: any;
        }>;
    };
    stop: () => void;
    swarm: {
        addrs: () => Promise<never>;
        connect: () => Promise<never>;
        disconnect: () => Promise<never>;
        localAddrs: () => Promise<any>;
        peers: () => Promise<never>;
    };
    version: (options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/version").Version>;
} : {
    add: (source: import("ipfs-core-utils/src/files/normalise-input/normalise-input").FileInput, options?: (import("./components/add").AddOptions & import("./utils").AbortOptions) | undefined) => Promise<import("./components/add-all").UnixFSEntry>; /**
     * Utility type to write type level conditionals
     *
     * @template Conditon, Then, Else
     * @typedef {NonNullable<Conditon> extends false ? Else : Then } If
     */
    addAll: (source: import("ipfs-core-utils/src/files/normalise-input/normalise-input").Source, options?: (import("./components/add-all").AddAllOptions & import("./utils").AbortOptions) | undefined) => AsyncIterable<import("./components/add-all").UnixFSEntry>;
    bitswap: {
        stat: (_options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/bitswap/stat").BitswapStats>;
        unwant: (cids: import("cids") | import("cids")[], options?: import("./utils").AbortOptions | undefined) => Promise<void>;
        wantlist: (options?: import("./utils").AbortOptions | undefined) => Promise<import("cids")[]>;
        wantlistForPeer: (peerId: string | import("cids") | Uint8Array | import("peer-id"), options?: import("./utils").AbortOptions | undefined) => Promise<import("cids")[]>;
    };
    block: import("./components").Block;
    bootstrap: {
        add: (multiaddr: import("multiaddr"), options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/bootstrap/utils").Peers>;
        clear: (options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/bootstrap/utils").Peers>;
        list: (options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/bootstrap/utils").Peers>;
        reset: (options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/bootstrap/utils").Peers>;
        rm: (multiaddr: import("multiaddr"), options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/bootstrap/utils").Peers>;
    };
    cat: (ipfsPath: string | import("cids"), options?: (import("./components/cat").CatOptions & import("./utils").AbortOptions) | undefined) => AsyncIterable<Uint8Array>;
    config: import("./components/config").Config;
    dag: import("./components").DAG;
    dht: {
        get: (key: string | Uint8Array, options?: import("./utils").AbortOptions | undefined) => Promise<Uint8Array>;
        put: (key: Uint8Array, value: Uint8Array, options?: import("./utils").AbortOptions | undefined) => AsyncIterable<import("./components/dht").QueryEvent>;
        findProvs: (cid: import("cids"), options?: (import("./components/dht").FindProvsOptions & import("./utils").AbortOptions) | undefined) => AsyncIterable<import("./components/dht").PeerInfo>;
        findPeer: (peerId: import("cids") | import("peer-id"), options?: import("./utils").AbortOptions | undefined) => Promise<{
            id: string;
            addrs: import("multiaddr")[];
        }>;
        provide: (cids: import("cids") | import("cids")[], options?: (import("./components/dht").ProvideOptions & import("./utils").AbortOptions) | undefined) => AsyncIterable<import("./components/dht").QueryEvent>;
        query: (peerId: string | import("peer-id"), options?: import("./utils").AbortOptions | undefined) => AsyncIterable<{
            id: import("cids");
            addrs: import("multiaddr")[];
        }>;
    } | {
        get: () => Promise<never>;
        put: () => Promise<never>;
        findProvs: () => AsyncGenerator<never, never, unknown>;
        findPeer: () => Promise<never>;
        provide: () => AsyncGenerator<never, never, unknown>;
        query: () => AsyncGenerator<never, never, unknown>;
    };
    dns: (domain: string, options?: (import("./components/dns").DNSSettings & import("./utils").AbortOptions) | undefined) => Promise<string>;
    files: import("./components/files").MFS | undefined;
    get: (ipfsPath: string | import("cids"), options?: (import("./components/get").GetOptions & import("./utils").AbortOptions) | undefined) => AsyncIterable<import("./utils").File | import("./utils").Directory>;
    id: (_options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/id").PeerId>;
    init: () => Promise<never>;
    isOnline: () => boolean;
    ipld: typeof import("./components");
    key: {
        export: (name?: any, password?: any, options?: any) => any;
        gen: (name?: any, options?: any) => any;
        import: (name?: any, pem?: any, password?: any, options?: any) => any;
        info: (name?: any, options?: any) => any;
        list: (options?: any) => any;
        rename: (oldName?: any, newName?: any, options?: any) => Promise<{
            was: any;
            now: any;
            id: any;
            overwrite: boolean;
        }>;
        rm: (name?: any, options?: any) => any;
    };
    libp2p: any;
    ls: (ipfsPath: string | import("cids"), options?: (import("./components/ls").LSOptions & import("./utils").AbortOptions) | undefined) => AsyncIterable<import("./utils").File | import("./utils").Directory>;
    name: {
        pubsub: {
            cancel: (name: string, options?: import("./utils").AbortOptions | undefined) => Promise<{
                canceled: boolean;
            }>;
            state: (_options?: import("./utils").AbortOptions | undefined) => Promise<{
                enabled: boolean;
            }>;
            subs: (options?: import("./utils").AbortOptions | undefined) => Promise<string[]>;
        };
        publish: (value: string, options?: (import("./components/name/publish").PublishSettings & import("./utils").AbortOptions) | undefined) => Promise<import("./components/name/publish").PublishResult>;
        resolve: (name: string, options?: (import("./components/name/resolve").ResolveSettings & import("./utils").AbortOptions) | undefined) => AsyncIterable<string>;
    };
    object: {
        data: (multihash?: any, options?: any) => Promise<any>;
        get: (multihash?: any, options?: any) => Promise<any>;
        links: (multihash?: any, options?: any) => Promise<any>;
        new: (options?: any) => Promise<any>;
        patch: {
            addLink: (multihash?: any, link?: any, options?: any) => Promise<any>;
            appendData: (multihash?: any, data?: any, options?: any) => Promise<any>;
            rmLink: (multihash?: any, linkRef?: any, options?: any) => Promise<any>;
            setData: (multihash?: any, data?: any, options?: any) => Promise<any>;
        };
        put: (obj?: any, options?: any) => Promise<any>;
        stat: (multihash?: any, options?: any) => Promise<{
            Hash: any;
            NumLinks: any;
            BlockSize: any;
            LinksSize: number;
            DataSize: any;
            CumulativeSize: any;
        }>;
    };
    pin: import("./components").Pin;
    ping: (peerId: import("peer-id"), options?: (import("./components/ping").PingSettings & import("./utils").AbortOptions) | undefined) => AsyncIterable<import("./components/ping").Pong | import("./components/ping").PingFailure | import("./components/ping").StatusUpdate>;
    pubsub: {
        subscribe: (...args: any[]) => any;
        unsubscribe: (...args: any[]) => any;
        publish: (topic?: any, data?: any, _options?: any) => Promise<void>;
        ls: (...args: any[]) => any;
        peers: (...args: any[]) => any;
    };
    refs: ((ipfsPath?: any, options?: any) => AsyncGenerator<{
        ref: any;
    }, void, unknown>) & {
        local: (options?: any) => AsyncGenerator<{
            ref: any;
        }, void, any>;
    };
    repo: {
        gc: (_options?: import("./utils").AbortOptions | undefined) => AsyncIterable<import("./components/repo/gc").Err | import("./components/repo/gc").BlockID>;
        stat: (options?: any) => Promise<{
            numObjects: any;
            repoSize: any;
            repoPath: any;
            version: any;
            storageMax: any;
        }>;
        version: (options?: any) => Promise<any>;
    };
    resolve: (path: string, opts?: (import("./components/resolve").ResolveSettings & import("./utils").AbortOptions) | undefined) => Promise<string>;
    start: () => {};
    stats: {
        bitswap: (_options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/bitswap/stat").BitswapStats>;
        bw: ((options?: any) => AsyncGenerator<{
            totalIn: any;
            totalOut: any;
            rateIn: import("bignumber.js").default;
            rateOut: import("bignumber.js").default;
        }, void, any>) | (() => Promise<never>);
        repo: (options?: any) => Promise<{
            numObjects: any;
            repoSize: any;
            repoPath: any;
            version: any;
            storageMax: any;
        }>;
    };
    stop: (_options: import("./utils").AbortOptions) => Promise<void>;
    swarm: {
        addrs: (options?: any) => Promise<{
            id: any;
            addrs: any;
        }[]>;
        connect: (addr?: any, options?: any) => any;
        disconnect: (addr?: any, options?: any) => any;
        localAddrs: () => Promise<any>;
        peers: (options?: any) => Promise<{
            addr: any;
            peer: any;
        }[]>;
    };
    version: (options?: import("./utils").AbortOptions | undefined) => Promise<import("./components/version").Version>;
}>;
export const crypto: typeof import("libp2p-crypto");
export const isIPFS: any;
export const CID: typeof import("cids");
export const multiaddr: typeof import("multiaddr");
export const multibase: typeof import("multibase/src/");
export const multihash: any;
export const multihashing: any;
export const multicodec: any;
export const PeerId: typeof import("peer-id");
export const globSource: any;
export const urlSource: any;
//# sourceMappingURL=index.d.ts.map