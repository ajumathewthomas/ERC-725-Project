declare function _exports({ repo }: {
    repo: import('.').IPFSRepo;
}): Config;
declare namespace _exports {
    export { profiles };
    export { Config, Get, GetAll, Set, Replace, Profiles, ListProfiles, Profile, ApplyProfile, ApplyOptionsExt, ApplyOptions, AbortOptions, IPFSConfig, AddressConfig, Multiaddr, APIAddress, DelegateAddress, GatewayAddress, SwarmAddress, BootstrapConfig, DatastoreConfig, DatastoreSpec, DiscoveryConfig, MDNSDiscovery, WebRTCStarDiscovery, IdentityConfig, PeerID, PrivateKey, KeychainConfig, DEK, PubsubConfig, PubSubRouter, SwarmConfig, ConnMgrConfig };
}
export = _exports;
export type Config = {
    get: Get;
    getAll: GetAll;
    set: Set;
    replace: Replace;
    profiles: Profiles;
};
/**
 * Returns the currently being used config. If the daemon is off, it returns
 * the stored config.
 */
export type Get = (key?: string | undefined, options?: import("../utils.js").AbortOptions | undefined) => Promise<JSON>;
/**
 * Returns the full config been used. If the daemon is off, it returns the
 * stored config.
 */
export type GetAll = (options?: import("../utils.js").AbortOptions | undefined) => Promise<IPFSConfig>;
/**
 * Adds or replaces a config value. Note that this operation will not spark the
 * restart of any service, i.e: if a config.replace changes the multiaddrs of
 * the Swarm, Swarm will have to be restarted manually for the changes to take
 * an effect.
 */
export type Set = (key: string, value: JSON, options?: import("../utils.js").AbortOptions | undefined) => Promise<void>;
/**
 * Adds or replaces a config file.
 *
 * Note that this operation will not spark the restart of any service,
 * i.e: if a config.replace changes the multiaddrs of the Swarm, Swarm will
 * have to be restarted manually for the changes to take an effect.
 */
export type Replace = (value: Partial<IPFSConfig>, options?: import("../utils.js").AbortOptions | undefined) => Promise<void>;
export type Profiles = {
    list: ListProfiles;
    apply: ApplyProfile;
};
/**
 * List available config profiles
 */
export type ListProfiles = (options?: import("../utils.js").AbortOptions | undefined) => Promise<Profile[]>;
export type Profile = {
    description: string;
    name: string;
};
/**
 * List available config profiles
 */
export type ApplyProfile = (name: string, options?: (import("../utils.js").AbortOptions & ApplyOptionsExt) | undefined) => Promise<{
    original: IPFSConfig;
    updated: IPFSConfig;
}>;
export type ApplyOptionsExt = {
    /**
     * - If true does not apply the profile
     */
    dryRun?: boolean | undefined;
};
export type ApplyOptions = import("../utils.js").AbortOptions & ApplyOptionsExt;
export type AbortOptions = {
    /**
     * - A timeout in ms
     */
    timeout?: number | undefined;
    /**
     * - Can be used to cancel any long running requests started as a result of this call
     */
    signal?: AbortSignal | undefined;
};
export type IPFSConfig = {
    Addresses: AddressConfig;
    Profiles?: string | undefined;
    Bootstrap?: string[] | undefined;
    Discovery: DiscoveryConfig;
    Datastore?: DatastoreConfig | undefined;
    Identity?: IdentityConfig | undefined;
    Keychain?: KeychainConfig | undefined;
    Pubsub?: PubsubConfig | undefined;
    Swarm?: SwarmConfig | undefined;
};
/**
 * Contains information about various listener addresses to be used by this node.
 */
export type AddressConfig = {
    API?: string | string[] | undefined;
    Delegates?: string[] | undefined;
    Gateway?: string | string[] | undefined;
    /**
     * *
     */
    Swarm?: string[] | undefined;
};
/**
 * Composable and future-proof network address following [Multiaddr][]
 * specification.
 *
 * [Multiaddr]:https://github.com/multiformats/multiaddr/
 */
export type Multiaddr = string;
/**
 * The IPFS daemon exposes an [HTTP API][] that allows to control the node and
 * run the same commands as you can do from the command line. It is defined on
 * the [HTTP API][] Spec.
 *
 * [Multiaddr][] or array of [Multiaddr][] describing the address(es) to serve the
 * [HTTP API][] on.
 *
 * [Multiaddr]:https://github.com/multiformats/multiaddr/
 * [HTTP API]:https://docs.ipfs.io/reference/api/http
 */
export type APIAddress = string | string[];
/**
 * Delegate peers are used to find peers and retrieve content from the network
 * on your behalf.
 *
 * Array of [Multiaddr][] describing which addresses to use as delegate nodes.
 *
 * [Multiaddr]:https://github.com/multiformats/multiaddr/
 */
export type DelegateAddress = string[];
/**
 * A gateway is exposed by the IPFS daemon, which allows an easy way to access
 * content from IPFS, using an IPFS path.
 *
 * [Multiaddr][] or array of [Multiaddr][] describing the address(es) to serve
 * the gateway on.
 *
 * [Multiaddr]:https://github.com/multiformats/multiaddr/
 */
export type GatewayAddress = string | string[];
/**
 * Array of [Multiaddr][] describing which addresses to listen on for p2p swarm
 * connections.
 *
 * [Multiaddr]:https://github.com/multiformats/multiaddr/
 */
export type SwarmAddress = string[];
/**
 * Bootstrap is an array of [Multiaddr][] of trusted nodes to connect to in order
 * to initiate a connection to the network.
 *
 * [Multiaddr]:https://github.com/multiformats/multiaddr/
 */
export type BootstrapConfig = string[];
/**
 * Contains information related to the construction and operation of the on-disk
 * storage system.
 */
export type DatastoreConfig = {
    Spec?: DatastoreSpec;
};
/**
 * Spec defines the structure of the IPFS datastore. It is a composable
 * structure, where each datastore is represented by a JSON object. Datastores
 * can wrap other datastores to provide extra functionality (e.g. metrics,
 * logging, or caching).
 *
 * This can be changed manually, however, if you make any changes that require
 * a different on-disk structure, you will need to run the [ipfs-ds-convert][]
 * tool to migrate data into the new structures.
 *
 * [ipfs-ds-convert]:https://github.com/ipfs/ipfs-ds-convert
 *
 * Default:
 * ```json
 * {
 * "mounts": [
 * {
 * "child": {
 * "path": "blocks",
 * "shardFunc": "/repo/flatfs/shard/v1/next-to-last/2",
 * "sync": true,
 * "type": "flatfs"
 * },
 * "mountpoint": "/blocks",
 * "prefix": "flatfs.datastore",
 * "type": "measure"
 * },
 * {
 * "child": {
 * "compression": "none",
 * "path": "datastore",
 * "type": "levelds"
 * },
 * "mountpoint": "/",
 * "prefix": "leveldb.datastore",
 * "type": "measure"
 * }
 * ],
 * "type": "mount"
 * }
 * ```
 */
export type DatastoreSpec = any;
/**
 * Contains options for configuring IPFS node discovery mechanisms.
 */
export type DiscoveryConfig = {
    MDNS: MDNSDiscovery;
    webRTCStar: WebRTCStarDiscovery;
};
/**
 * Multicast DNS is a discovery protocol that is able to find other peers on the local network.
 */
export type MDNSDiscovery = {
    /**
     * - A boolean value for whether or not MDNS
     * should be active.
     */
    Enabled?: boolean | undefined;
    /**
     * - A number of seconds to wait between
     * discovery checks.
     */
    Interval?: number | undefined;
};
/**
 * WebRTCStar is a discovery mechanism prvided by a signalling-star that allows
 * peer-to-peer communications in the browser.
 */
export type WebRTCStarDiscovery = {
    /**
     * - A boolean value for whether or not
     * webRTCStar should be active.
     */
    Enabled?: boolean | undefined;
};
export type IdentityConfig = {
    PeerID?: string | undefined;
    PrivKey?: string | undefined;
};
/**
 * The unique PKI identity label for this configs peer. Set on init and never
 * read, its merely here for convenience. IPFS will always generate the peerID
 * from its keypair at runtime.
 */
export type PeerID = string;
/**
 * The base64 encoded protobuf describing (and containing) the nodes private key.
 */
export type PrivateKey = string;
/**
 * We can customize the key management and criptographically protected messages
 * by changing the Keychain options. Those options are used for generating the
 * derived encryption key (DEK).
 *
 * The DEK object, along with the passPhrase, is the input to a PBKDF2 function.
 *
 * You can check the [parameter choice for pbkdf2](https://cryptosense.com/parameter-choice-for-pbkdf2/)
 * for more information.
 */
export type KeychainConfig = {
    DEK: DEK;
};
export type DEK = {
    keyLength: number;
    iterationCount: number;
    salt: string;
    hash: string;
};
/**
 * Options for configuring the pubsub subsystem. It is important pointing out
 * that this is not supported in the browser. If you want to configure a
 * different pubsub router in the browser you must configure
 * `libp2p.modules.pubsub` options instead.
 */
export type PubsubConfig = {
    Router?: "gossipsub" | "floodsub" | undefined;
    Enabled?: boolean | undefined;
};
/**
 * A string value for specifying which pubsub routing protocol to use. You can
 * either use `'gossipsub'` in order to use the [ChainSafe/gossipsub-js]
 * (https://github.com/ChainSafe/gossipsub-js) implementation, or `'floodsub'`
 * to use the [libp2p/js-libp2p-floodsub](https://github.com/libp2p/js-libp2p-floodsub)
 * implementation.
 *
 * You can read more about these implementations on the [libp2p/specs/pubsub]
 * (https://github.com/libp2p/specs/tree/master/pubsub) document.
 */
export type PubSubRouter = "gossipsub" | "floodsub";
/**
 * Options for configuring the swarm.
 */
export type SwarmConfig = {
    ConnMgr?: ConnMgrConfig | undefined;
};
/**
 * The connection manager determines which and how many connections to keep and
 * can be configured to keep.
 *
 * The "basic" connection manager tries to keep between `LowWater` and
 * `HighWater` connections. It works by:
 *
 * 1. Keeping all connections until `HighWater` connections is reached.
 * 2. Once `HighWater` is reached, it closes connections until `LowWater` is
 * reached.
 */
export type ConnMgrConfig = {
    /**
     * - The minimum number of connections to
     * maintain.
     */
    LowWater?: number | undefined;
    /**
     * - The number of connections that, when
     * exceeded, will trigger a connection GC operation.
     *
     * {{LowWater?:number, HighWater?:number}} ConnMgr
     */
    HighWater?: number | undefined;
};
declare const profiles: {
    server: {
        description: string;
        /**
         * @param {IPFSConfig} config
         * @returns {IPFSConfig}
         */
        transform: (config: IPFSConfig) => IPFSConfig;
    };
    'local-discovery': {
        description: string;
        /**
         * @param {IPFSConfig} config
         * @returns {IPFSConfig}
         */
        transform: (config: IPFSConfig) => IPFSConfig;
    };
    test: {
        description: string;
        /**
         * @param {IPFSConfig} config
         * @returns {IPFSConfig}
         */
        transform: (config: IPFSConfig) => IPFSConfig;
    };
    'default-networking': {
        description: string;
        /**
         * @param {IPFSConfig} config
         * @returns {IPFSConfig}
         */
        transform: (config: IPFSConfig) => IPFSConfig;
    };
    lowpower: {
        description: string;
        /**
         * @param {IPFSConfig} config
         * @returns {IPFSConfig}
         */
        transform: (config: IPFSConfig) => IPFSConfig;
    };
    'default-power': {
        description: string;
        /**
         * @param {IPFSConfig} config
         * @returns {IPFSConfig}
         */
        transform: (config: IPFSConfig) => IPFSConfig;
    };
};
//# sourceMappingURL=config.d.ts.map