declare function _exports({ libp2p, repo }: {
    libp2p: any;
    repo: any;
}): {
    get: (key: string | Uint8Array, options?: import("../utils").AbortOptions | undefined) => Promise<Uint8Array>;
    put: (key: Uint8Array, value: Uint8Array, options?: import("../utils").AbortOptions | undefined) => AsyncIterable<QueryEvent>;
    findProvs: (cid: import("cids"), options?: (FindProvsOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<PeerInfo>;
    findPeer: (peerId: import("cids") | import("peer-id"), options?: import("../utils").AbortOptions | undefined) => Promise<{
        id: string;
        addrs: Multiaddr[];
    }>;
    provide: (cids: import("cids") | import("cids")[], options?: (ProvideOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<QueryEvent>;
    query: (peerId: string | import("peer-id"), options?: import("../utils").AbortOptions | undefined) => AsyncIterable<{
        id: import("cids");
        addrs: Multiaddr[];
    }>;
};
export = _exports;
export type QueryEvent = {
    id: import("peer-id");
    type: number;
    extra: string;
    responses: PeerInfo[];
};
export type ProvideOptions = {
    /**
     * - Provide not only the given object but also all objects linked from it.
     */
    recursive?: boolean | undefined;
};
export type FindProvsOptions = {
    /**
     * - maximum number of providers to find
     */
    numProviders?: number | undefined;
    maxNumProviders?: number | undefined;
};
export type PeerInfo = {
    id: import("peer-id");
    addrs: Multiaddr[];
};
export type Multiaddr = import("multiaddr");
export type AbortOptions = {
    /**
     * - A timeout in ms
     */
    timeout?: number | undefined;
    /**
     * - Can be used to cancel any long running requests started as a result of this call
     */
    signal?: AbortSignal | undefined;
};
//# sourceMappingURL=dht.d.ts.map