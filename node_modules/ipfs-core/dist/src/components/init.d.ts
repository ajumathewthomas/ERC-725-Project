declare function _exports({ apiManager, print, options: constructorOptions }: {
    apiManager: import('../api-manager');
    print: (...args: any[]) => void;
    options: ConstructorOptions<boolean | InitOptions, boolean>;
}): (options?: any) => Promise<{
    add: any;
    addAll: any;
    bitswap: {
        stat: () => Promise<never>;
        unwant: () => Promise<never>;
        wantlist: () => Promise<never>;
        wantlistForPeer: () => Promise<never>;
    };
    bootstrap: {
        add: (multiaddr: import("multiaddr"), options?: import("../utils.js").AbortOptions | undefined) => Promise<import("./bootstrap/utils.js").Peers>;
        list: (options?: import("../utils.js").AbortOptions | undefined) => Promise<import("./bootstrap/utils.js").Peers>;
        rm: (multiaddr: import("multiaddr"), options?: import("../utils.js").AbortOptions | undefined) => Promise<import("./bootstrap/utils.js").Peers>;
    };
    block: any;
    cat: (ipfsPath: string | import("cids"), options?: (import("./cat.js").CatOptions & import("../utils.js").AbortOptions) | undefined) => AsyncIterable<Uint8Array>;
    config: import("./config.js").Config;
    dag: any;
    dns: (domain: string, options?: (import("./dns.js").DNSSettings & import("../utils.js").AbortOptions) | undefined) => Promise<string>;
    files: import("./files/index.js").MFS;
    get: (ipfsPath: string | import("cids"), options?: (import("./get.js").GetOptions & import("../utils.js").AbortOptions) | undefined) => AsyncIterable<import("../utils.js").File | import("../utils.js").Directory>;
    id: (_options?: import("../utils.js").AbortOptions | undefined) => Promise<import("./id.js").PeerId>;
    init: () => Promise<never>;
    isOnline: () => boolean;
    key: {
        export: (name?: any, password?: any, options?: any) => any;
        gen: (name?: any, options?: any) => any;
        import: (name?: any, pem?: any, password?: any, options?: any) => any;
        info: (name?: any, options?: any) => any;
        list: (options?: any) => any;
        rename: (oldName?: any, newName?: any, options?: any) => Promise<{
            was: any;
            now: any;
            id: any;
            overwrite: boolean;
        }>;
        rm: (name?: any, options?: any) => any;
    };
    ls: (ipfsPath: string | import("cids"), options?: (import("./ls.js").LSOptions & import("../utils.js").AbortOptions) | undefined) => AsyncIterable<import("../utils.js").File | import("../utils.js").Directory>;
    object: any;
    pin: any;
    refs: ((ipfsPath?: any, options?: any) => AsyncGenerator<{
        ref: any;
    }, void, unknown>) & {
        local: (options?: any) => AsyncGenerator<{
            ref: any;
        }, void, any>;
    };
    repo: {
        gc: (_options?: import("../utils.js").AbortOptions | undefined) => AsyncIterable<import("./repo/gc.js").Err | import("./repo/gc.js").BlockID>;
        stat: (options?: any) => Promise<{
            numObjects: any;
            repoSize: any;
            repoPath: any;
            version: any;
            storageMax: any;
        }>;
        version: (options?: any) => Promise<any>;
    };
    resolve: (path: string, opts?: (import("./resolve.js").ResolveSettings & import("../utils.js").AbortOptions) | undefined) => Promise<string>;
    start: () => Promise<{
        add: (source: import("ipfs-core-utils/src/files/normalise-input/normalise-input").FileInput, options?: (import("./add.js").AddOptions & import("../utils.js").AbortOptions) | undefined) => Promise<import("./add-all/index.js").UnixFSEntry>;
        addAll: (source: import("ipfs-core-utils/src/files/normalise-input/normalise-input").Source, options?: (import("./add-all/index.js").AddAllOptions & import("../utils.js").AbortOptions) | undefined) => AsyncIterable<import("./add-all/index.js").UnixFSEntry>;
        bitswap: {
            stat: (_options?: import("../utils.js").AbortOptions | undefined) => Promise<import("./bitswap/stat.js").BitswapStats>;
            unwant: (cids: import("cids") | import("cids")[], options?: import("../utils.js").AbortOptions | undefined) => Promise<void>;
            wantlist: (options?: import("../utils.js").AbortOptions | undefined) => Promise<import("cids")[]>;
            wantlistForPeer: (peerId: string | import("cids") | Uint8Array | import("peer-id"), options?: import("../utils.js").AbortOptions | undefined) => Promise<import("cids")[]>;
        };
        block: import("./index.js").Block;
        bootstrap: {
            add: (multiaddr: import("multiaddr"), options?: import("../utils.js").AbortOptions | undefined) => Promise<import("./bootstrap/utils.js").Peers>;
            clear: (options?: import("../utils.js").AbortOptions | undefined) => Promise<import("./bootstrap/utils.js").Peers>;
            list: (options?: import("../utils.js").AbortOptions | undefined) => Promise<import("./bootstrap/utils.js").Peers>;
            reset: (options?: import("../utils.js").AbortOptions | undefined) => Promise<import("./bootstrap/utils.js").Peers>;
            rm: (multiaddr: import("multiaddr"), options?: import("../utils.js").AbortOptions | undefined) => Promise<import("./bootstrap/utils.js").Peers>;
        };
        cat: (ipfsPath: string | import("cids"), options?: (import("./cat.js").CatOptions & import("../utils.js").AbortOptions) | undefined) => AsyncIterable<Uint8Array>;
        config: import("./config.js").Config;
        dag: import("./index.js").DAG;
        dht: {
            get: (key: string | Uint8Array, options?: import("../utils.js").AbortOptions | undefined) => Promise<Uint8Array>;
            put: (key: Uint8Array, value: Uint8Array, options?: import("../utils.js").AbortOptions | undefined) => AsyncIterable<import("./dht.js").QueryEvent>;
            findProvs: (cid: import("cids"), options?: (import("./dht.js").FindProvsOptions & import("../utils.js").AbortOptions) | undefined) => AsyncIterable<import("./dht.js").PeerInfo>;
            findPeer: (peerId: import("cids") | import("peer-id"), options?: import("../utils.js").AbortOptions | undefined) => Promise<{
                id: string;
                addrs: import("multiaddr")[];
            }>;
            provide: (cids: import("cids") | import("cids")[], options?: (import("./dht.js").ProvideOptions & import("../utils.js").AbortOptions) | undefined) => AsyncIterable<import("./dht.js").QueryEvent>;
            query: (peerId: string | import("peer-id"), options?: import("../utils.js").AbortOptions | undefined) => AsyncIterable<{
                id: import("cids");
                addrs: import("multiaddr")[];
            }>;
        } | {
            get: () => Promise<never>;
            put: () => Promise<never>;
            findProvs: () => AsyncGenerator<never, never, unknown>;
            findPeer: () => Promise<never>;
            provide: () => AsyncGenerator<never, never, unknown>;
            query: () => AsyncGenerator<never, never, unknown>;
        };
        dns: (domain: string, options?: (import("./dns.js").DNSSettings & import("../utils.js").AbortOptions) | undefined) => Promise<string>;
        files: import("./files/index.js").MFS | undefined;
        get: (ipfsPath: string | import("cids"), options?: (import("./get.js").GetOptions & import("../utils.js").AbortOptions) | undefined) => AsyncIterable<import("../utils.js").File | import("../utils.js").Directory>;
        id: (_options?: import("../utils.js").AbortOptions | undefined) => Promise<import("./id.js").PeerId>;
        init: () => Promise<never>;
        isOnline: () => boolean;
        ipld: typeof import("./index.js");
        key: {
            export: (name?: any, password?: any, options?: any) => any;
            gen: (name?: any, options?: any) => any;
            import: (name?: any, pem?: any, password?: any, options?: any) => any;
            info: (name?: any, options?: any) => any;
            list: (options?: any) => any;
            rename: (oldName?: any, newName?: any, options?: any) => Promise<{
                was: any;
                now: any;
                id: any;
                overwrite: boolean;
            }>;
            rm: (name?: any, options?: any) => any;
        };
        libp2p: any;
        ls: (ipfsPath: string | import("cids"), options?: (import("./ls.js").LSOptions & import("../utils.js").AbortOptions) | undefined) => AsyncIterable<import("../utils.js").File | import("../utils.js").Directory>;
        name: {
            pubsub: {
                cancel: (name: string, options?: import("../utils.js").AbortOptions | undefined) => Promise<{
                    canceled: boolean;
                }>;
                state: (_options?: import("../utils.js").AbortOptions | undefined) => Promise<{
                    enabled: boolean;
                }>;
                subs: (options?: import("../utils.js").AbortOptions | undefined) => Promise<string[]>;
            };
            publish: (value: string, options?: (import("./name/publish.js").PublishSettings & import("../utils.js").AbortOptions) | undefined) => Promise<import("./name/publish.js").PublishResult>;
            resolve: (name: string, options?: (import("./name/resolve.js").ResolveSettings & import("../utils.js").AbortOptions) | undefined) => AsyncIterable<string>;
        };
        object: {
            data: (multihash?: any, options?: any) => Promise<any>;
            get: (multihash?: any, options?: any) => Promise<any>;
            links: (multihash?: any, options?: any) => Promise<any>;
            new: (options?: any) => Promise<any>;
            patch: {
                addLink: (multihash?: any, link?: any, options?: any) => Promise<any>;
                appendData: (multihash?: any, data?: any, options?: any) => Promise<any>;
                rmLink: (multihash?: any, linkRef?: any, options?: any) => Promise<any>;
                setData: (multihash?: any, data?: any, options?: any) => Promise<any>;
            };
            put: (obj?: any, options?: any) => Promise<any>;
            stat: (multihash?: any, options?: any) => Promise<{
                Hash: any;
                NumLinks: any;
                BlockSize: any;
                LinksSize: number;
                DataSize: any;
                CumulativeSize: any;
            }>;
        };
        pin: import("./index.js").Pin;
        ping: (peerId: import("peer-id"), options?: (import("./ping.js").PingSettings & import("../utils.js").AbortOptions) | undefined) => AsyncIterable<import("./ping.js").Pong | import("./ping.js").PingFailure | import("./ping.js").StatusUpdate>;
        pubsub: {
            subscribe: (...args: any[]) => any;
            unsubscribe: (...args: any[]) => any;
            publish: (topic?: any, data?: any, _options?: any) => Promise<void>;
            ls: (...args: any[]) => any;
            peers: (...args: any[]) => any;
        };
        refs: ((ipfsPath?: any, options?: any) => AsyncGenerator<{
            ref: any;
        }, void, unknown>) & {
            local: (options?: any) => AsyncGenerator<{
                ref: any;
            }, void, any>;
        };
        repo: {
            gc: (_options?: import("../utils.js").AbortOptions | undefined) => AsyncIterable<import("./repo/gc.js").Err | import("./repo/gc.js").BlockID>;
            stat: (options?: any) => Promise<{
                numObjects: any;
                repoSize: any;
                repoPath: any;
                version: any;
                storageMax: any;
            }>;
            version: (options?: any) => Promise<any>;
        };
        resolve: (path: string, opts?: (import("./resolve.js").ResolveSettings & import("../utils.js").AbortOptions) | undefined) => Promise<string>;
        start: () => {};
        stats: {
            bitswap: (_options?: import("../utils.js").AbortOptions | undefined) => Promise<import("./bitswap/stat.js").BitswapStats>;
            bw: ((options?: any) => AsyncGenerator<{
                totalIn: any;
                totalOut: any;
                rateIn: import("bignumber.js").default;
                rateOut: import("bignumber.js").default;
            }, void, any>) | (() => Promise<never>);
            repo: (options?: any) => Promise<{
                numObjects: any;
                repoSize: any;
                repoPath: any;
                version: any;
                storageMax: any;
            }>;
        };
        stop: (_options: import("../utils.js").AbortOptions) => Promise<void>;
        swarm: {
            addrs: (options?: any) => Promise<{
                id: any;
                addrs: any;
            }[]>;
            connect: (addr?: any, options?: any) => any;
            disconnect: (addr?: any, options?: any) => any;
            localAddrs: () => Promise<any>;
            peers: (options?: any) => Promise<{
                addr: any;
                peer: any;
            }[]>;
        };
        version: (options?: import("../utils.js").AbortOptions | undefined) => Promise<import("./version.js").Version>;
    }>;
    stats: {
        bitswap: () => Promise<never>;
        bw: () => Promise<never>;
        repo: (options?: any) => Promise<{
            numObjects: any;
            repoSize: any;
            repoPath: any;
            version: any;
            storageMax: any;
        }>;
    };
    stop: () => void;
    swarm: {
        addrs: () => Promise<never>;
        connect: () => Promise<never>;
        disconnect: () => Promise<never>;
        localAddrs: () => Promise<any>;
        peers: () => Promise<never>;
    };
    version: (options?: import("../utils.js").AbortOptions | undefined) => Promise<import("./version.js").Version>;
}>;
export = _exports;
export type IPLD = any;
/**
 * Options argument can be used to specify advanced configuration.
 */
export type ConstructorOptions<Init extends boolean | InitOptions, Start extends boolean> = {
    repo?: RepoOption;
    /**
     * - `js-ipfs` comes bundled with a
     * tool that automatically migrates your IPFS repository when a new version is
     * available.
     */
    repoAutoMigrate?: boolean | undefined;
    /**
     * - Perform repo initialization steps when creating
     * the IPFS node.
     * Note that *initializing* a repo is different from creating an instance of
     * [`ipfs.Repo`](https://github.com/ipfs/js-ipfs-repo). The IPFS constructor
     * sets many special properties when initializing a repo, so you should usually
     * not try and call `repoInstance.init()` yourself.
     */
    init?: Init | undefined;
    /**
     * - If `false`, do not automatically
     * start the IPFS node. Instead, you’ll need to manually call
     * [`node.start()`](https://github.com/ipfs/js-ipfs/blob/master/packages/ipfs/docs/MODULE.md#nodestart)
     * yourself.
     */
    start?: Start | undefined;
    /**
     * - A passphrase to encrypt/decrypt your keys.
     */
    pass?: string | undefined;
    /**
     * - Prevents all logging output from the
     * IPFS node. (Default: `false`)
     */
    silent?: boolean | undefined;
    /**
     * - Configure circuit relay (see the [circuit relay tutorial]
     * (https://github.com/ipfs/js-ipfs/tree/master/examples/circuit-relaying)
     * to learn more).
     */
    relay?: RelayOptions | undefined;
    /**
     * - Run ipfs node offline. The node does
     * not connect to the rest of the network but provides a local API.
     */
    offline?: boolean | undefined;
    /**
     * - Configure remote preload nodes.
     * The remote will preload content added on this node, and also attempt to
     * preload objects requested by this node.
     */
    preload?: PreloadOptions | undefined;
    /**
     * - Enable and configure
     * experimental features.
     */
    EXPERIMENTAL?: ExperimentalOptions | undefined;
    /**
     * - Modify the default IPFS node config. This
     * object will be *merged* with the default config; it will not replace it.
     * (Default: [`config-nodejs.js`](https://github.com/ipfs/js-ipfs/tree/master/packages/ipfs/src/core/runtime/config-nodejs.js)
     * in Node.js, [`config-browser.js`](https://github.com/ipfs/js-ipfs/tree/master/packages/ipfs/src/core/runtime/config-browser.js)
     * in browsers)
     */
    config?: object;
    /**
     * - Modify the default IPLD config. This object
     * will be *merged* with the default config; it will not replace it. Check IPLD
     * [docs](https://github.com/ipld/js-ipld#ipld-constructor) for more information
     * on the available options. (Default: [`ipld.js`]
     * (https://github.com/ipfs/js-ipfs/tree/master/packages/ipfs/src/core/runtime/ipld.js)
     * in browsers)
     */
    ipld?: any;
    /**
     * - The libp2p option allows you to build
     * your libp2p node by configuration, or via a bundle function. If you are
     * looking to just modify the below options, using the object format is the
     * quickest way to get the default features of libp2p. If you need to create a
     * more customized libp2p node, such as with custom transports or peer/content
     * routers that need some of the ipfs data on startup, a custom bundle is a
     * great way to achieve this.
     * - You can see the bundle in action in the [custom libp2p example](https://github.com/ipfs/js-ipfs/tree/master/examples/custom-libp2p).
     * - Please see [libp2p/docs/CONFIGURATION.md](https://github.com/libp2p/js-libp2p/blob/master/doc/CONFIGURATION.md)
     * for the list of options libp2p supports.
     * - Default: [`libp2p-nodejs.js`](../src/core/runtime/libp2p-nodejs.js)
     * in Node.js, [`libp2p-browser.js`](../src/core/runtime/libp2p-browser.js) in
     * browsers.
     */
    libp2p?: object | Function;
    repoOwner?: boolean | undefined;
};
/**
 * The file path at which to store the IPFS node’s data. Alternatively, you
 * can set up a customized storage system by providing an `ipfs.Repo` instance.
 */
export type RepoOption = any;
export type RelayOptions = {
    /**
     * - Enable circuit relay dialer and listener. (Default: `true`)
     */
    enabled?: boolean | undefined;
    hop?: {
        /**
         * - Make this node a relay (other nodes can connect *through* it). (Default: `false`)
         */
        enabled?: boolean | undefined;
        /**
         * - Make this an *active* relay node. Active relay nodes will attempt to dial a destination peer even if that peer is not yet connected to the relay. (Default: `false`)
         */
        active?: boolean | undefined;
    } | undefined;
};
export type PreloadOptions = {
    /**
     * - Enable content preloading (Default: `true`)
     */
    enabled?: boolean | undefined;
    interval?: number | undefined;
    /**
     * - Multiaddr API addresses of nodes that should preload content.
     * **NOTE:** nodes specified here should also be added to your node's bootstrap address list at `config.Boostrap`.
     */
    addresses?: string[] | undefined;
};
export type ExperimentalOptions = {
    /**
     * - Enable pub-sub on IPNS. (Default: `false`)
     */
    ipnsPubsub?: boolean | undefined;
    /**
     * - Enable directory sharding. Directories that have many child objects will be represented by multiple DAG nodes instead of just one. It can improve lookup performance when a directory has several thousand files or more. (Default: `false`)
     */
    sharding?: boolean | undefined;
};
export type InitOptions = {
    /**
     * - Whether to remove built-in assets,
     * like the instructional tour and empty mutable file system, from the repo.
     */
    emptyRepo?: boolean | undefined;
    /**
     * - Number of bits to use in the generated key
     * pair (rsa only).
     */
    bits?: number | undefined;
    /**
     * - A pre-generated private key to use.
     * **NOTE: This overrides `bits`.**
     */
    privateKey?: string | import("peer-id") | undefined;
    /**
     * - A passphrase to encrypt keys. You should
     * generally use the top-level `pass` option instead of the `init.pass`
     * option (this one will take its value from the top-level option if not set).
     */
    pass?: string | undefined;
    /**
     * - Apply profile settings to config.
     */
    profiles?: string[] | undefined;
    /**
     * - Set to `false` to disallow
     * initialization if the repo does not already exist.
     */
    allowNew?: boolean | undefined;
    config?: import("./config.js").IPFSConfig | undefined;
};
export type IPFSConfig = {
    Addresses: import("./config.js").AddressConfig;
    Profiles?: string | undefined;
    Bootstrap?: string[] | undefined;
    Discovery: import("./config.js").DiscoveryConfig;
    Datastore?: import("./config.js").DatastoreConfig | undefined;
    Identity?: import("./config.js").IdentityConfig | undefined;
    Keychain?: import("./config.js").KeychainConfig | undefined;
    Pubsub?: import("./config.js").PubsubConfig | undefined;
    Swarm?: import("./config.js").SwarmConfig | undefined;
};
export type IPFSRepo = any;
export type KeyType = "RSA" | "ed25519" | "secp256k1";
/**
 * Can be either a base64 string or a [PeerId](https://github.com/libp2p/js-peer-id)
 * instance.
 */
export type PrivateKey = string | import("peer-id");
export type Keychain = any;
//# sourceMappingURL=init.d.ts.map