export var add: ({ addAll }: {
    addAll: any;
}) => (source: import("ipfs-core-utils/src/files/normalise-input/normalise-input").FileInput, options?: (import("./add").AddOptions & import("../utils").AbortOptions) | undefined) => Promise<import("./add-all").UnixFSEntry>;
export var addAll: ({ block, gcLock, preload, pin, options: constructorOptions }: {
    block: Block;
    gcLock: RWLock;
    preload: ((() => void) & {
        start: () => void;
        stop: () => void;
    }) | {
        (path: string | import("cids")): Promise<void>;
        start(): void;
        stop(): void;
    };
    pin: Pin;
    options: import("./init").ConstructorOptions<any, boolean>;
}) => (source: import("ipfs-core-utils/src/files/normalise-input/normalise-input").Source, options?: (import("./add-all").AddAllOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./add-all").UnixFSEntry>;
export namespace block {
    const get: ({ blockService, preload }: {
        blockService: any;
        preload: ((() => void) & {
            start: () => void;
            stop: () => void;
        }) | {
            (path: string | import("cids")): Promise<void>;
            start(): void;
            stop(): void;
        };
    }) => (cid: string | import("cids") | Uint8Array, options?: (import("./block/get").GetOptions & import("../utils").AbortOptions) | undefined) => Promise<import("ipld-block/src")>;
    const put: ({ blockService, pin, gcLock, preload }: {
        blockService: any;
        pin: Pin;
        gcLock: RWLock;
        preload: ((() => void) & {
            start: () => void;
            stop: () => void;
        }) | {
            (path: string | import("cids")): Promise<void>;
            start(): void;
            stop(): void;
        };
    }) => (block: Uint8Array | import("ipld-block/src"), options?: (import("./block/put").PutOptions & import("../utils").AbortOptions) | undefined) => Promise<import("ipld-block/src")>;
    const rm: ({ blockService, gcLock, pinManager }: {
        blockService: any;
        pinManager: import("./pin/pin-manager");
        gcLock: RWLock;
    }) => (cids: import("cids") | import("cids")[], options?: (import("./block/rm").RmOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./block/rm").RmSucceess | import("./block/rm").RmFailure>;
    const stat: ({ blockService, preload }: {
        blockService: any;
        preload: ((() => void) & {
            start: () => void;
            stop: () => void;
        }) | {
            (path: string | import("cids")): Promise<void>;
            start(): void;
            stop(): void;
        };
    }) => (cid: import("cids"), options?: (import("./block/stat").StatOptions & import("../utils").AbortOptions) | undefined) => Promise<import("./block/stat").Stat>;
}
export namespace bitswap {
    const stat_1: ({ bitswap }: {
        bitswap: any;
    }) => (_options?: import("../utils").AbortOptions | undefined) => Promise<import("./bitswap/stat").BitswapStats>;
    export { stat_1 as stat };
    export const unwant: ({ bitswap }: {
        bitswap: any;
    }) => (cids: import("cids") | import("cids")[], options?: import("../utils").AbortOptions | undefined) => Promise<void>;
    export const wantlist: ({ bitswap }: {
        bitswap: any;
    }) => (options?: import("../utils").AbortOptions | undefined) => Promise<import("cids")[]>;
    export const wantlistForPeer: ({ bitswap }: {
        bitswap: any;
    }) => (peerId: string | import("cids") | Uint8Array | import("peer-id"), options?: import("../utils").AbortOptions | undefined) => Promise<import("cids")[]>;
}
export namespace bootstrap {
    export const add: ({ repo }: any) => (multiaddr: import("multiaddr"), options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
    export const clear: ({ repo }: {
        repo: any;
    }) => (options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
    export const list: ({ repo }: any) => (options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
    export const reset: ({ repo }: any) => (options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
    const rm_1: ({ repo }: any) => (multiaddr: import("multiaddr"), options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
    export { rm_1 as rm };
}
export var cat: ({ ipld, preload }: {
    ipld: any;
    preload: ((() => void) & {
        start: () => void;
        stop: () => void;
    }) | {
        (path: string | import("cids")): Promise<void>;
        start(): void;
        stop(): void;
    };
}) => (ipfsPath: string | import("cids"), options?: (import("./cat").CatOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<Uint8Array>;
export var config: {
    ({ repo }: {
        repo: any;
    }): import("./config").Config;
    profiles: {
        server: {
            description: string;
            transform: (config: import("./config").IPFSConfig) => import("./config").IPFSConfig;
        };
        'local-discovery': {
            description: string;
            transform: (config: import("./config").IPFSConfig) => import("./config").IPFSConfig;
        };
        test: {
            description: string;
            transform: (config: import("./config").IPFSConfig) => import("./config").IPFSConfig;
        };
        'default-networking': {
            description: string;
            transform: (config: import("./config").IPFSConfig) => import("./config").IPFSConfig;
        };
        lowpower: {
            description: string;
            transform: (config: import("./config").IPFSConfig) => import("./config").IPFSConfig;
        };
        'default-power': {
            description: string;
            transform: (config: import("./config").IPFSConfig) => import("./config").IPFSConfig;
        };
    };
};
export namespace dag {
    const get_1: ({ ipld, preload }: {
        ipld: any;
        preload: ((() => void) & {
            start: () => void;
            stop: () => void;
        }) | {
            (path: string | import("cids")): Promise<void>;
            start(): void;
            stop(): void;
        };
    }) => (ipfsPath: import("cids"), options?: (import("./dag/get").GetOptions & import("../utils").AbortOptions) | undefined) => Promise<import("./dag/get").DagEntry>;
    export { get_1 as get };
    const put_1: ({ ipld, pin, gcLock, preload }: {
        ipld: any;
        pin: Pin;
        gcLock: RWLock;
        preload: ((() => void) & {
            start: () => void;
            stop: () => void;
        }) | {
            (path: string | import("cids")): Promise<void>;
            start(): void;
            stop(): void;
        };
    }) => (dagNode: any, options?: (import("./dag/put").PutOptions & import("../utils").AbortOptions) | undefined) => Promise<import("cids")>;
    export { put_1 as put };
    export const resolve: ({ ipld, preload }: {
        ipld: any;
        preload: ((() => void) & {
            start: () => void;
            stop: () => void;
        }) | {
            (path: string | import("cids")): Promise<void>;
            start(): void;
            stop(): void;
        };
    }) => (ipfsPath: string | import("cids"), options?: (import("./dag/resolve").ResolveOptions & import("../utils").AbortOptions) | undefined) => Promise<import("./dag/resolve").ResolveResult>;
    export const tree: ({ ipld, preload }: {
        ipld: any;
        preload: ((() => void) & {
            start: () => void;
            stop: () => void;
        }) | {
            (path: string | import("cids")): Promise<void>;
            start(): void;
            stop(): void;
        };
    }) => (ipfsPath: import("cids"), options?: (import("./dag/tree").TreeOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<string>;
}
export var dht: ({ libp2p, repo }: {
    libp2p: any;
    repo: any;
}) => {
    get: (key: string | Uint8Array, options?: import("../utils").AbortOptions | undefined) => Promise<Uint8Array>;
    put: (key: Uint8Array, value: Uint8Array, options?: import("../utils").AbortOptions | undefined) => AsyncIterable<import("./dht").QueryEvent>;
    findProvs: (cid: import("cids"), options?: (import("./dht").FindProvsOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./dht").PeerInfo>;
    findPeer: (peerId: import("cids") | import("peer-id"), options?: import("../utils").AbortOptions | undefined) => Promise<{
        id: string;
        addrs: import("multiaddr")[];
    }>;
    provide: (cids: import("cids") | import("cids")[], options?: (import("./dht").ProvideOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./dht").QueryEvent>;
    query: (peerId: string | import("peer-id"), options?: import("../utils").AbortOptions | undefined) => AsyncIterable<{
        id: import("cids");
        addrs: import("multiaddr")[];
    }>;
};
export var dns: () => (domain: string, options?: (import("./dns").DNSSettings & import("../utils").AbortOptions) | undefined) => Promise<string>;
export var files: ({ ipld, block, blockService, repo, preload, options: constructorOptions }: {
    ipld: any;
    block: Block;
    blockService: any;
    repo: any;
    preload: ((() => void) & {
        start: () => void;
        stop: () => void;
    }) | {
        (path: string | import("cids")): Promise<void>;
        start(): void;
        stop(): void;
    };
    options: import("./init").ConstructorOptions<any, any>;
}) => import("./files").MFS;
export var get: ({ ipld, preload }: {
    ipld: any;
    preload: ((() => void) & {
        start: () => void;
        stop: () => void;
    }) | {
        (path: string | import("cids")): Promise<void>;
        start(): void;
        stop(): void;
    };
}) => (ipfsPath: string | import("cids"), options?: (import("./get").GetOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("../utils").File | import("../utils").Directory>;
export var id: ({ peerId, libp2p }: {
    peerId: import("peer-id");
    libp2p?: any;
}) => (_options?: import("../utils").AbortOptions | undefined) => Promise<import("./id").PeerId>;
export var init: ({ apiManager, print, options: constructorOptions }: {
    apiManager: import("../api-manager");
    print: (...args: any[]) => void;
    options: import("./init").ConstructorOptions<boolean | import("./init").InitOptions, boolean>;
}) => (options?: any) => Promise<{
    add: any;
    addAll: any;
    bitswap: {
        stat: () => Promise<never>;
        unwant: () => Promise<never>;
        wantlist: () => Promise<never>;
        wantlistForPeer: () => Promise<never>;
    };
    bootstrap: {
        add: (multiaddr: import("multiaddr"), options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
        list: (options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
        rm: (multiaddr: import("multiaddr"), options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
    };
    block: any;
    cat: (ipfsPath: string | import("cids"), options?: (import("./cat").CatOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<Uint8Array>;
    config: import("./config").Config;
    dag: any;
    dns: (domain: string, options?: (import("./dns").DNSSettings & import("../utils").AbortOptions) | undefined) => Promise<string>;
    files: import("./files").MFS;
    get: (ipfsPath: string | import("cids"), options?: (import("./get").GetOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("../utils").File | import("../utils").Directory>;
    id: (_options?: import("../utils").AbortOptions | undefined) => Promise<import("./id").PeerId>;
    init: () => Promise<never>;
    isOnline: () => boolean;
    key: {
        export: (name?: any, password?: any, options?: any) => any;
        gen: (name?: any, options?: any) => any;
        import: (name?: any, pem?: any, password?: any, options?: any) => any;
        info: (name?: any, options?: any) => any;
        list: (options?: any) => any;
        rename: (oldName?: any, newName?: any, options?: any) => Promise<{
            was: any;
            now: any;
            id: any;
            overwrite: boolean;
        }>;
        rm: (name?: any, options?: any) => any;
    };
    ls: (ipfsPath: string | import("cids"), options?: (import("./ls").LSOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("../utils").File | import("../utils").Directory>;
    object: any;
    pin: any;
    refs: ((ipfsPath?: any, options?: any) => AsyncGenerator<{
        ref: any;
    }, void, unknown>) & {
        local: (options?: any) => AsyncGenerator<{
            ref: any;
        }, void, any>;
    };
    repo: {
        gc: (_options?: import("../utils").AbortOptions | undefined) => AsyncIterable<import("./repo/gc").Err | import("./repo/gc").BlockID>;
        stat: (options?: any) => Promise<{
            numObjects: any;
            repoSize: any;
            repoPath: any;
            version: any;
            storageMax: any;
        }>;
        version: (options?: any) => Promise<any>;
    };
    resolve: (path: string, opts?: (import("./resolve").ResolveSettings & import("../utils").AbortOptions) | undefined) => Promise<string>;
    start: () => Promise<{
        add: (source: import("ipfs-core-utils/src/files/normalise-input/normalise-input").FileInput, options?: (import("./add").AddOptions & import("../utils").AbortOptions) | undefined) => Promise<import("./add-all").UnixFSEntry>;
        addAll: (source: import("ipfs-core-utils/src/files/normalise-input/normalise-input").Source, options?: (import("./add-all").AddAllOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./add-all").UnixFSEntry>;
        bitswap: {
            stat: (_options?: import("../utils").AbortOptions | undefined) => Promise<import("./bitswap/stat").BitswapStats>;
            unwant: (cids: import("cids") | import("cids")[], options?: import("../utils").AbortOptions | undefined) => Promise<void>;
            wantlist: (options?: import("../utils").AbortOptions | undefined) => Promise<import("cids")[]>;
            wantlistForPeer: (peerId: string | import("cids") | Uint8Array | import("peer-id"), options?: import("../utils").AbortOptions | undefined) => Promise<import("cids")[]>;
        };
        block: Block;
        bootstrap: {
            add: (multiaddr: import("multiaddr"), options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
            clear: (options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
            list: (options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
            reset: (options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
            rm: (multiaddr: import("multiaddr"), options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
        };
        cat: (ipfsPath: string | import("cids"), options?: (import("./cat").CatOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<Uint8Array>;
        config: import("./config").Config;
        dag: DAG;
        dht: {
            get: (key: string | Uint8Array, options?: import("../utils").AbortOptions | undefined) => Promise<Uint8Array>;
            put: (key: Uint8Array, value: Uint8Array, options?: import("../utils").AbortOptions | undefined) => AsyncIterable<import("./dht").QueryEvent>;
            findProvs: (cid: import("cids"), options?: (import("./dht").FindProvsOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./dht").PeerInfo>;
            findPeer: (peerId: import("cids") | import("peer-id"), options?: import("../utils").AbortOptions | undefined) => Promise<{
                id: string;
                addrs: import("multiaddr")[];
            }>;
            provide: (cids: import("cids") | import("cids")[], options?: (import("./dht").ProvideOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./dht").QueryEvent>;
            query: (peerId: string | import("peer-id"), options?: import("../utils").AbortOptions | undefined) => AsyncIterable<{
                id: import("cids");
                addrs: import("multiaddr")[];
            }>;
        } | {
            get: () => Promise<never>;
            put: () => Promise<never>;
            findProvs: () => AsyncGenerator<never, never, unknown>;
            findPeer: () => Promise<never>;
            provide: () => AsyncGenerator<never, never, unknown>;
            query: () => AsyncGenerator<never, never, unknown>;
        };
        dns: (domain: string, options?: (import("./dns").DNSSettings & import("../utils").AbortOptions) | undefined) => Promise<string>;
        files: import("./files").MFS | undefined;
        get: (ipfsPath: string | import("cids"), options?: (import("./get").GetOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("../utils").File | import("../utils").Directory>;
        id: (_options?: import("../utils").AbortOptions | undefined) => Promise<import("./id").PeerId>;
        init: () => Promise<never>;
        isOnline: () => boolean;
        ipld: typeof import(".");
        key: {
            export: (name?: any, password?: any, options?: any) => any;
            gen: (name?: any, options?: any) => any;
            import: (name?: any, pem?: any, password?: any, options?: any) => any;
            info: (name?: any, options?: any) => any;
            list: (options?: any) => any;
            rename: (oldName?: any, newName?: any, options?: any) => Promise<{
                was: any;
                now: any;
                id: any;
                overwrite: boolean;
            }>;
            rm: (name?: any, options?: any) => any;
        };
        libp2p: any;
        ls: (ipfsPath: string | import("cids"), options?: (import("./ls").LSOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("../utils").File | import("../utils").Directory>;
        name: {
            pubsub: {
                cancel: (name: string, options?: import("../utils").AbortOptions | undefined) => Promise<{
                    canceled: boolean;
                }>;
                state: (_options?: import("../utils").AbortOptions | undefined) => Promise<{
                    enabled: boolean;
                }>;
                subs: (options?: import("../utils").AbortOptions | undefined) => Promise<string[]>;
            };
            publish: (value: string, options?: (import("./name/publish").PublishSettings & import("../utils").AbortOptions) | undefined) => Promise<import("./name/publish").PublishResult>;
            resolve: (name: string, options?: (import("./name/resolve").ResolveSettings & import("../utils").AbortOptions) | undefined) => AsyncIterable<string>;
        };
        object: {
            data: (multihash?: any, options?: any) => Promise<any>;
            get: (multihash?: any, options?: any) => Promise<any>;
            links: (multihash?: any, options?: any) => Promise<any>;
            new: (options?: any) => Promise<any>;
            patch: {
                addLink: (multihash?: any, link?: any, options?: any) => Promise<any>;
                appendData: (multihash?: any, data?: any, options?: any) => Promise<any>;
                rmLink: (multihash?: any, linkRef?: any, options?: any) => Promise<any>;
                setData: (multihash?: any, data?: any, options?: any) => Promise<any>;
            };
            put: (obj?: any, options?: any) => Promise<any>;
            stat: (multihash?: any, options?: any) => Promise<{
                Hash: any;
                NumLinks: any;
                BlockSize: any;
                LinksSize: number;
                DataSize: any;
                CumulativeSize: any;
            }>;
        };
        pin: Pin;
        ping: (peerId: import("peer-id"), options?: (import("./ping").PingSettings & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./ping").Pong | import("./ping").PingFailure | import("./ping").StatusUpdate>;
        pubsub: {
            subscribe: (...args: any[]) => any;
            unsubscribe: (...args: any[]) => any;
            publish: (topic?: any, data?: any, _options?: any) => Promise<void>;
            ls: (...args: any[]) => any;
            peers: (...args: any[]) => any;
        };
        refs: ((ipfsPath?: any, options?: any) => AsyncGenerator<{
            ref: any;
        }, void, unknown>) & {
            local: (options?: any) => AsyncGenerator<{
                ref: any;
            }, void, any>;
        };
        repo: {
            gc: (_options?: import("../utils").AbortOptions | undefined) => AsyncIterable<import("./repo/gc").Err | import("./repo/gc").BlockID>;
            stat: (options?: any) => Promise<{
                numObjects: any;
                repoSize: any;
                repoPath: any;
                version: any;
                storageMax: any;
            }>;
            version: (options?: any) => Promise<any>;
        };
        resolve: (path: string, opts?: (import("./resolve").ResolveSettings & import("../utils").AbortOptions) | undefined) => Promise<string>;
        start: () => {};
        stats: {
            bitswap: (_options?: import("../utils").AbortOptions | undefined) => Promise<import("./bitswap/stat").BitswapStats>;
            bw: ((options?: any) => AsyncGenerator<{
                totalIn: any;
                totalOut: any;
                rateIn: import("bignumber.js").default;
                rateOut: import("bignumber.js").default;
            }, void, any>) | (() => Promise<never>);
            repo: (options?: any) => Promise<{
                numObjects: any;
                repoSize: any;
                repoPath: any;
                version: any;
                storageMax: any;
            }>;
        };
        stop: (_options: import("../utils").AbortOptions) => Promise<void>;
        swarm: {
            addrs: (options?: any) => Promise<{
                id: any;
                addrs: any;
            }[]>;
            connect: (addr?: any, options?: any) => any;
            disconnect: (addr?: any, options?: any) => any;
            localAddrs: () => Promise<any>;
            peers: (options?: any) => Promise<{
                addr: any;
                peer: any;
            }[]>;
        };
        version: (options?: import("../utils").AbortOptions | undefined) => Promise<import("./version").Version>;
    }>;
    stats: {
        bitswap: () => Promise<never>;
        bw: () => Promise<never>;
        repo: (options?: any) => Promise<{
            numObjects: any;
            repoSize: any;
            repoPath: any;
            version: any;
            storageMax: any;
        }>;
    };
    stop: () => void;
    swarm: {
        addrs: () => Promise<never>;
        connect: () => Promise<never>;
        disconnect: () => Promise<never>;
        localAddrs: () => Promise<any>;
        peers: () => Promise<never>;
    };
    version: (options?: import("../utils").AbortOptions | undefined) => Promise<import("./version").Version>;
}>;
export var isOnline: ({ libp2p }: {
    libp2p?: any;
}) => () => boolean;
export namespace key {
    const _export: ({ keychain }: {
        keychain: any;
    }) => (name?: any, password?: any, options?: any) => any;
    export { _export as export };
    export const gen: ({ keychain }: {
        keychain: any;
    }) => (name?: any, options?: any) => any;
    const _import: ({ keychain }: {
        keychain: any;
    }) => (name?: any, pem?: any, password?: any, options?: any) => any;
    export { _import as import };
    export const info: ({ keychain }: {
        keychain: any;
    }) => (name?: any, options?: any) => any;
    const list_1: ({ keychain }: {
        keychain: any;
    }) => (options?: any) => any;
    export { list_1 as list };
    export const rename: ({ keychain }: {
        keychain: any;
    }) => (oldName?: any, newName?: any, options?: any) => Promise<{
        was: any;
        now: any;
        id: any;
        overwrite: boolean;
    }>;
    const rm_2: ({ keychain }: {
        keychain: any;
    }) => (name?: any, options?: any) => any;
    export { rm_2 as rm };
}
export var libp2p: ({ options, peerId, multiaddrs, repo, keychainConfig, config }: {
    repo: any;
    options?: any;
    peerId?: import("peer-id") | undefined;
    multiaddrs?: string[] | undefined;
    keychainConfig?: {
        pass?: string | undefined;
    } | undefined;
    config?: any;
}) => any;
export var ls: ({ ipld, preload }: {
    ipld: any;
    preload: ((() => void) & {
        start: () => void;
        stop: () => void;
    }) | {
        (path: string | import("cids")): Promise<void>;
        start(): void;
        stop(): void;
    };
}) => (ipfsPath: string | import("cids"), options?: (import("./ls").LSOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("../utils").File | import("../utils").Directory>;
export namespace name {
    export const publish: ({ ipns, dag, peerId, isOnline, keychain }: {
        ipns: import("../ipns");
        dag: DAG;
        /**
         * @typedef {Object} BitSwap
         * @property {ReturnType<typeof import('./bitswap/stat')>} stat
         * @property {ReturnType<typeof import('./bitswap/unwant')>} unwant
         * @property {ReturnType<typeof import('./bitswap/wantlist')>} wantlist
         */
        peerId: import("peer-id");
        isOnline: () => boolean;
        keychain: any;
    }) => (value: string, options?: (import("./name/publish").PublishSettings & import("../utils").AbortOptions) | undefined) => Promise<import("./name/publish").PublishResult>;
    export namespace pubsub {
        const cancel: ({ ipns, options: constructorOptions }: {
            ipns: import("../ipns");
            options: import("./init").ConstructorOptions<any, any>;
        }) => (name: string, options?: import("../utils").AbortOptions | undefined) => Promise<{
            canceled: boolean;
        }>;
        const state: ({ ipns, options: constructorOptions }: {
            ipns: any;
            options: any;
        }) => (_options?: import("../utils").AbortOptions | undefined) => Promise<{
            enabled: boolean;
        }>;
        const subs: ({ ipns, options: constructorOptions }: {
            ipns: any;
            options: any;
        }) => (options?: import("../utils").AbortOptions | undefined) => Promise<string[]>;
    }
    const resolve_1: ({ dns, ipns, peerId, isOnline, options: constructorOptions }: {
        dns: (domain: string, options?: (import("./dns").DNSSettings & import("../utils").AbortOptions) | undefined) => Promise<string>;
        ipns: import("../ipns");
        peerId: import("peer-id");
        isOnline: () => boolean;
        options: {
            offline?: boolean | undefined;
        };
    }) => (name: string, options?: (import("./name/resolve").ResolveSettings & import("../utils").AbortOptions) | undefined) => AsyncIterable<string>;
    export { resolve_1 as resolve };
}
export namespace object {
    export const data: ({ ipld, preload }: {
        ipld: any;
        preload: any;
    }) => (multihash?: any, options?: any) => Promise<any>;
    const get_2: ({ ipld, preload }: {
        ipld: any;
        preload: any;
    }) => (multihash?: any, options?: any) => Promise<any>;
    export { get_2 as get };
    export const links: ({ dag }: {
        dag: any;
    }) => (multihash?: any, options?: any) => Promise<any>;
    const _new: ({ ipld, preload }: {
        ipld: any;
        preload: any;
    }) => (options?: any) => Promise<any>;
    export { _new as new };
    export namespace patch {
        const addLink: ({ ipld, gcLock, preload }: {
            ipld: any;
            gcLock: any;
            preload: any;
        }) => (multihash?: any, link?: any, options?: any) => Promise<any>;
        const appendData: ({ ipld, gcLock, preload }: {
            ipld: any;
            gcLock: any;
            preload: any;
        }) => (multihash?: any, data?: any, options?: any) => Promise<any>;
        const rmLink: ({ ipld, gcLock, preload }: {
            ipld: any;
            gcLock: any;
            preload: any;
        }) => (multihash?: any, linkRef?: any, options?: any) => Promise<any>;
        const setData: ({ ipld, gcLock, preload }: {
            ipld: any;
            gcLock: any;
            preload: any;
        }) => (multihash?: any, data?: any, options?: any) => Promise<any>;
    }
    const put_2: ({ ipld, gcLock, preload }: {
        ipld: any;
        gcLock: any;
        preload: any;
    }) => (obj?: any, options?: any) => Promise<any>;
    export { put_2 as put };
    const stat_2: ({ ipld, preload }: {
        ipld: any;
        preload: any;
    }) => (multihash?: any, options?: any) => Promise<{
        Hash: any;
        NumLinks: any;
        BlockSize: any;
        LinksSize: number;
        DataSize: any;
        CumulativeSize: any;
    }>;
    export { stat_2 as stat };
}
export namespace pin {
    const add_1: ({ addAll }: {
        addAll: (source: import("ipfs-core-utils/src/pins/normalise-input").Source, options?: (import("./pin/add-all").AddSettings & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("cids")>;
    }) => (path: string | import("cids"), options?: (import("./pin/add").AddOptions & import("../utils").AbortOptions) | undefined) => Promise<import("cids")>;
    export { add_1 as add };
    export const addAll: ({ pinManager, gcLock, dag }: {
        gcLock: RWLock;
        dag: DAG;
        pinManager: import("./pin/pin-manager");
    }) => (source: import("ipfs-core-utils/src/pins/normalise-input").Source, options?: (import("./pin/add-all").AddSettings & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("cids")>;
    export const ls: ({ pinManager, dag }: {
        pinManager: import("./pin/pin-manager");
        dag: DAG;
    }) => (options?: (import("./pin/ls").LsSettings & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./pin/ls").LsEntry>;
    const rm_3: ({ rmAll }: {
        rmAll: (source: import("ipfs-core-utils/src/pins/normalise-input").Source, _options?: import("../utils").AbortOptions | undefined) => AsyncIterable<import("cids")>;
    }) => (path: string | import("cids"), options?: (import("./pin/rm").RmSettings & import("../utils").AbortOptions) | undefined) => Promise<import("cids")>;
    export { rm_3 as rm };
    export const rmAll: ({ pinManager, gcLock, dag }: {
        pinManager: import("./pin/pin-manager");
        gcLock: RWLock;
        dag: DAG;
    }) => (source: import("ipfs-core-utils/src/pins/normalise-input").Source, _options?: import("../utils").AbortOptions | undefined) => AsyncIterable<import("cids")>;
}
export var ping: ({ libp2p }: {
    libp2p: any;
}) => (peerId: import("peer-id"), options?: (import("./ping").PingSettings & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./ping").Pong | import("./ping").PingFailure | import("./ping").StatusUpdate>;
export var pubsub: ({ libp2p }: {
    libp2p: any;
}) => {
    subscribe: (...args: any[]) => any;
    unsubscribe: (...args: any[]) => any;
    publish: (topic?: any, data?: any, _options?: any) => Promise<void>;
    ls: (...args: any[]) => any;
    peers: (...args: any[]) => any;
};
export var refs: {
    ({ ipld, resolve, preload }: {
        ipld: any;
        resolve: any;
        preload: any;
    }): (ipfsPath?: any, options?: any) => AsyncGenerator<{
        ref: any;
    }, void, unknown>;
    Format: {
        default: string;
        edges: string;
    };
} & {
    local: ({ repo }: {
        repo: any;
    }) => (options?: any) => AsyncGenerator<{
        ref: any;
    }, void, any>;
};
export namespace repo {
    export const gc: ({ gcLock, pin, refs, repo }: {
        gcLock: RWLock;
        pin: Pin;
        refs: (ipfsPath?: any, options?: any) => AsyncGenerator<{
            ref: any;
        }, void, unknown>;
        repo: any;
    }) => (_options?: import("../utils").AbortOptions | undefined) => AsyncIterable<import("./repo/gc").Err | import("./repo/gc").BlockID>;
    const stat_3: ({ repo }: {
        repo: any;
    }) => (options?: any) => Promise<{
        numObjects: any;
        repoSize: any;
        repoPath: any;
        version: any;
        storageMax: any;
    }>;
    export { stat_3 as stat };
    export const version: ({ repo }: {
        repo: any;
    }) => (options?: any) => Promise<any>;
}
export var resolve: ({ ipld, name }: {
    ipld: any;
    name?: Name | undefined;
}) => (path: string, opts?: (import("./resolve").ResolveSettings & import("../utils").AbortOptions) | undefined) => Promise<string>;
export var start: ({ apiManager, options: constructorOptions, blockService, gcLock, initOptions, ipld, keychain, peerId, pinManager, preload, print, repo }: {
    apiManager: import("../api-manager");
    options: import("./init").ConstructorOptions<boolean | import("./init").InitOptions, true>;
    blockService: any;
    gcLock: RWLock;
    initOptions: import("./init").InitOptions;
    ipld: typeof import(".");
    keychain: any;
    peerId: import("peer-id");
    pinManager: import("./pin/pin-manager");
    preload: ((() => void) & {
        start: () => void;
        stop: () => void;
    }) | {
        (path: string | import("cids")): Promise<void>;
        start(): void;
        stop(): void;
    };
    print: (...args: any[]) => void;
    repo: any;
}) => () => Promise<{
    add: (source: import("ipfs-core-utils/src/files/normalise-input/normalise-input").FileInput, options?: (import("./add").AddOptions & import("../utils").AbortOptions) | undefined) => Promise<import("./add-all").UnixFSEntry>;
    addAll: (source: import("ipfs-core-utils/src/files/normalise-input/normalise-input").Source, options?: (import("./add-all").AddAllOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./add-all").UnixFSEntry>;
    bitswap: {
        stat: (_options?: import("../utils").AbortOptions | undefined) => Promise<import("./bitswap/stat").BitswapStats>;
        unwant: (cids: import("cids") | import("cids")[], options?: import("../utils").AbortOptions | undefined) => Promise<void>;
        wantlist: (options?: import("../utils").AbortOptions | undefined) => Promise<import("cids")[]>;
        wantlistForPeer: (peerId: string | import("cids") | Uint8Array | import("peer-id"), options?: import("../utils").AbortOptions | undefined) => Promise<import("cids")[]>;
    };
    block: Block;
    bootstrap: {
        add: (multiaddr: import("multiaddr"), options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
        clear: (options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
        list: (options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
        reset: (options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
        rm: (multiaddr: import("multiaddr"), options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
    };
    cat: (ipfsPath: string | import("cids"), options?: (import("./cat").CatOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<Uint8Array>;
    config: import("./config").Config;
    dag: DAG;
    dht: {
        get: (key: string | Uint8Array, options?: import("../utils").AbortOptions | undefined) => Promise<Uint8Array>;
        put: (key: Uint8Array, value: Uint8Array, options?: import("../utils").AbortOptions | undefined) => AsyncIterable<import("./dht").QueryEvent>;
        findProvs: (cid: import("cids"), options?: (import("./dht").FindProvsOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./dht").PeerInfo>;
        findPeer: (peerId: import("cids") | import("peer-id"), options?: import("../utils").AbortOptions | undefined) => Promise<{
            id: string;
            addrs: import("multiaddr")[];
        }>;
        provide: (cids: import("cids") | import("cids")[], options?: (import("./dht").ProvideOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./dht").QueryEvent>;
        query: (peerId: string | import("peer-id"), options?: import("../utils").AbortOptions | undefined) => AsyncIterable<{
            id: import("cids");
            addrs: import("multiaddr")[];
        }>;
    } | {
        get: () => Promise<never>;
        put: () => Promise<never>;
        findProvs: () => AsyncGenerator<never, never, unknown>;
        findPeer: () => Promise<never>;
        provide: () => AsyncGenerator<never, never, unknown>;
        query: () => AsyncGenerator<never, never, unknown>;
    };
    dns: (domain: string, options?: (import("./dns").DNSSettings & import("../utils").AbortOptions) | undefined) => Promise<string>;
    files: import("./files").MFS | undefined;
    get: (ipfsPath: string | import("cids"), options?: (import("./get").GetOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("../utils").File | import("../utils").Directory>;
    id: (_options?: import("../utils").AbortOptions | undefined) => Promise<import("./id").PeerId>;
    init: () => Promise<never>;
    isOnline: () => boolean;
    ipld: typeof import(".");
    key: {
        export: (name?: any, password?: any, options?: any) => any;
        gen: (name?: any, options?: any) => any;
        import: (name?: any, pem?: any, password?: any, options?: any) => any;
        info: (name?: any, options?: any) => any;
        list: (options?: any) => any;
        rename: (oldName?: any, newName?: any, options?: any) => Promise<{
            was: any;
            now: any;
            id: any;
            overwrite: boolean;
        }>;
        rm: (name?: any, options?: any) => any;
    };
    libp2p: any;
    ls: (ipfsPath: string | import("cids"), options?: (import("./ls").LSOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("../utils").File | import("../utils").Directory>;
    name: {
        pubsub: {
            cancel: (name: string, options?: import("../utils").AbortOptions | undefined) => Promise<{
                canceled: boolean;
            }>;
            state: (_options?: import("../utils").AbortOptions | undefined) => Promise<{
                enabled: boolean;
            }>;
            subs: (options?: import("../utils").AbortOptions | undefined) => Promise<string[]>;
        };
        publish: (value: string, options?: (import("./name/publish").PublishSettings & import("../utils").AbortOptions) | undefined) => Promise<import("./name/publish").PublishResult>;
        resolve: (name: string, options?: (import("./name/resolve").ResolveSettings & import("../utils").AbortOptions) | undefined) => AsyncIterable<string>;
    };
    object: {
        data: (multihash?: any, options?: any) => Promise<any>;
        get: (multihash?: any, options?: any) => Promise<any>;
        links: (multihash?: any, options?: any) => Promise<any>;
        new: (options?: any) => Promise<any>;
        patch: {
            addLink: (multihash?: any, link?: any, options?: any) => Promise<any>;
            appendData: (multihash?: any, data?: any, options?: any) => Promise<any>;
            rmLink: (multihash?: any, linkRef?: any, options?: any) => Promise<any>;
            setData: (multihash?: any, data?: any, options?: any) => Promise<any>;
        };
        put: (obj?: any, options?: any) => Promise<any>;
        stat: (multihash?: any, options?: any) => Promise<{
            Hash: any;
            NumLinks: any;
            BlockSize: any;
            LinksSize: number;
            DataSize: any;
            CumulativeSize: any;
        }>;
    };
    pin: Pin;
    ping: (peerId: import("peer-id"), options?: (import("./ping").PingSettings & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./ping").Pong | import("./ping").PingFailure | import("./ping").StatusUpdate>;
    pubsub: {
        subscribe: (...args: any[]) => any;
        unsubscribe: (...args: any[]) => any;
        publish: (topic?: any, data?: any, _options?: any) => Promise<void>;
        ls: (...args: any[]) => any;
        peers: (...args: any[]) => any;
    };
    refs: ((ipfsPath?: any, options?: any) => AsyncGenerator<{
        ref: any;
    }, void, unknown>) & {
        local: (options?: any) => AsyncGenerator<{
            ref: any;
        }, void, any>;
    };
    repo: {
        gc: (_options?: import("../utils").AbortOptions | undefined) => AsyncIterable<import("./repo/gc").Err | import("./repo/gc").BlockID>;
        stat: (options?: any) => Promise<{
            numObjects: any;
            repoSize: any;
            repoPath: any;
            version: any;
            storageMax: any;
        }>;
        version: (options?: any) => Promise<any>;
    };
    resolve: (path: string, opts?: (import("./resolve").ResolveSettings & import("../utils").AbortOptions) | undefined) => Promise<string>;
    start: () => {};
    stats: {
        bitswap: (_options?: import("../utils").AbortOptions | undefined) => Promise<import("./bitswap/stat").BitswapStats>;
        bw: ((options?: any) => AsyncGenerator<{
            totalIn: any;
            totalOut: any;
            rateIn: import("bignumber.js").default;
            rateOut: import("bignumber.js").default;
        }, void, any>) | (() => Promise<never>);
        repo: (options?: any) => Promise<{
            numObjects: any;
            repoSize: any;
            repoPath: any;
            version: any;
            storageMax: any;
        }>;
    };
    stop: (_options: import("../utils").AbortOptions) => Promise<void>;
    swarm: {
        addrs: (options?: any) => Promise<{
            id: any;
            addrs: any;
        }[]>;
        connect: (addr?: any, options?: any) => any;
        disconnect: (addr?: any, options?: any) => any;
        localAddrs: () => Promise<any>;
        peers: (options?: any) => Promise<{
            addr: any;
            peer: any;
        }[]>;
    };
    version: (options?: import("../utils").AbortOptions | undefined) => Promise<import("./version").Version>;
}>;
export namespace stats {
    const bw: ({ libp2p }: {
        libp2p: any;
    }) => (options?: any) => AsyncGenerator<{
        totalIn: any;
        totalOut: any;
        rateIn: import("bignumber.js").default;
        rateOut: import("bignumber.js").default;
    }, void, any>;
}
export var stop: ({ apiManager, options: constructorOptions, bitswap, blockService, gcLock, initOptions, ipld, ipns, keychain, libp2p, mfsPreload, peerId, pinManager, preload, print, repo }: {
    apiManager: any;
    options: any;
    bitswap: any;
    blockService: any;
    gcLock: any;
    initOptions: any;
    ipld: any;
    ipns: any;
    keychain: any;
    libp2p: any;
    mfsPreload: any;
    peerId: any;
    pinManager?: {} | undefined;
    preload: any;
    print: any;
    repo: any;
}) => (_options: import("../utils").AbortOptions) => Promise<void>;
export namespace swarm {
    const addrs: ({ libp2p }: {
        libp2p: any;
    }) => (options?: any) => Promise<{
        id: any;
        addrs: any;
    }[]>;
    const connect: ({ libp2p }: {
        libp2p: any;
    }) => (addr?: any, options?: any) => any;
    const disconnect: ({ libp2p }: {
        libp2p: any;
    }) => (addr?: any, options?: any) => any;
    const localAddrs: ({ multiaddrs }: {
        multiaddrs: any;
    }) => () => Promise<any>;
    const peers: ({ libp2p }: {
        libp2p: any;
    }) => (options?: any) => Promise<{
        addr: any;
        peer: any;
    }[]>;
}
export var version: ({ repo }: {
    repo: any;
}) => (options?: import("../utils").AbortOptions | undefined) => Promise<import("./version").Version>;
export type Add = (source: import("ipfs-core-utils/src/files/normalise-input/normalise-input").FileInput, options?: (import("./add").AddOptions & import("../utils").AbortOptions) | undefined) => Promise<import("./add-all").UnixFSEntry>;
export type AddAll = (source: import("ipfs-core-utils/src/files/normalise-input/normalise-input").Source, options?: (import("./add-all").AddAllOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./add-all").UnixFSEntry>;
export type Block = {
    get: ReturnType<typeof import('./block/get')>;
    put: ReturnType<typeof import('./block/put')>;
    rm: ReturnType<typeof import('./block/rm')>;
    stat: ReturnType<typeof import('./block/stat')>;
};
export type BitSwap = {
    stat: ReturnType<typeof import('./bitswap/stat')>;
    unwant: ReturnType<typeof import('./bitswap/unwant')>;
    wantlist: ReturnType<typeof import('./bitswap/wantlist')>;
};
export type Bootstrap = {
    add: ReturnType<typeof import('./bootstrap/add')>;
    list: ReturnType<typeof import('./bootstrap/list')>;
    rm: ReturnType<typeof import('./bootstrap/rm')>;
};
export type Cat = (ipfsPath: string | import("cids"), options?: (import("./cat").CatOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<Uint8Array>;
export type Config = {
    get: import("./config").Get;
    getAll: import("./config").GetAll;
    set: import("./config").Set;
    replace: import("./config").Replace;
    profiles: import("./config").Profiles;
};
export type DAG = {
    get: ReturnType<typeof import('./dag/get')>;
    put: ReturnType<typeof import('./dag/put')>;
    resolve: ReturnType<typeof import('./dag/resolve')>;
    tree: ReturnType<typeof import('./dag/tree')>;
};
export type DHT = {
    get: (key: string | Uint8Array, options?: import("../utils").AbortOptions | undefined) => Promise<Uint8Array>;
    put: (key: Uint8Array, value: Uint8Array, options?: import("../utils").AbortOptions | undefined) => AsyncIterable<import("./dht").QueryEvent>;
    findProvs: (cid: import("cids"), options?: (import("./dht").FindProvsOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./dht").PeerInfo>;
    findPeer: (peerId: import("cids") | import("peer-id"), options?: import("../utils").AbortOptions | undefined) => Promise<{
        id: string;
        addrs: import("multiaddr")[];
    }>;
    provide: (cids: import("cids") | import("cids")[], options?: (import("./dht").ProvideOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./dht").QueryEvent>;
    query: (peerId: string | import("peer-id"), options?: import("../utils").AbortOptions | undefined) => AsyncIterable<{
        id: import("cids");
        addrs: import("multiaddr")[];
    }>;
};
export type DNS = (domain: string, options?: (import("./dns").DNSSettings & import("../utils").AbortOptions) | undefined) => Promise<string>;
export type Files = {
    stat: (path: string, options?: (import("./files/stat").StatOptions & import("../utils").AbortOptions) | undefined) => Promise<import("./files/stat").Stat>;
    chmod: (path: string, mode: string | number, options?: (import("./files/chmod").ChmodOptions & import("../utils").AbortOptions) | undefined) => Promise<void>;
    cp: (...args: [string | import("cids"), (import("./files/cp").CpOptions | undefined)?] | [string | import("cids"), string | import("cids"), (import("./files/cp").CpOptions | undefined)?] | [string | import("cids"), string | import("cids"), string | import("cids"), (import("./files/cp").CpOptions | undefined)?] | [string | import("cids"), string | import("cids"), string | import("cids"), string | import("cids"), (import("./files/cp").CpOptions | undefined)?] | [string | import("cids"), string | import("cids"), string | import("cids"), string | import("cids"), string | import("cids"), (import("./files/cp").CpOptions | undefined)?] | [string | import("cids"), string | import("cids"), string | import("cids"), string | import("cids"), string | import("cids"), string | import("cids"), (import("./files/cp").CpOptions | undefined)?] | [string | import("cids"), string | import("cids"), string | import("cids"), string | import("cids"), string | import("cids"), string | import("cids"), string | import("cids"), (import("./files/cp").CpOptions | undefined)?] | [string | import("cids"), string | import("cids"), string | import("cids"), string | import("cids"), string | import("cids"), string | import("cids"), string | import("cids"), string | import("cids"), (import("./files/cp").CpOptions | undefined)?]) => Promise<void>;
    flush: (path: string, options?: import("../utils").AbortOptions | undefined) => Promise<import("cids")>;
    mkdir: (path: string, options?: (import("./files/mkdir").MkdirOptions & import("../utils").AbortOptions) | undefined) => Promise<void>;
    mv: (...args: [string, string, (import("./files/mv").MvOptions | undefined)?] | [string, string, string, (import("./files/mv").MvOptions | undefined)?] | [string, string, string, string, (import("./files/mv").MvOptions | undefined)?] | [string, string, string, string, string, (import("./files/mv").MvOptions | undefined)?] | [string, string, string, string, string, string, (import("./files/mv").MvOptions | undefined)?] | [string, string, string, string, string, string, string, (import("./files/mv").MvOptions | undefined)?] | [string, string, string, string, string, string, string, string, (import("./files/mv").MvOptions | undefined)?] | [string, string, string, string, string, string, string, string, string, (import("./files/mv").MvOptions | undefined)?]) => Promise<void>;
    rm: (...args: [string, (import("./files/rm").RmOptions | undefined)?] | [string, string, (import("./files/rm").RmOptions | undefined)?] | [string, string, string, (import("./files/rm").RmOptions | undefined)?] | [string, string, string, string, (import("./files/rm").RmOptions | undefined)?] | [string, string, string, string, string, (import("./files/rm").RmOptions | undefined)?] | [string, string, string, string, string, string, (import("./files/rm").RmOptions | undefined)?] | [string, string, string, string, string, string, string, (import("./files/rm").RmOptions | undefined)?] | [string, string, string, string, string, string, string, string, (import("./files/rm").RmOptions | undefined)?]) => Promise<void>;
    touch: (path: string, options?: (import("./files/touch").TouchOptions & import("../utils").AbortOptions) | undefined) => Promise<void>;
    write: (path: string, content: string | Uint8Array | AsyncIterable<Uint8Array> | Blob, options?: (import("./files/write").WriteOptions & import("../utils").AbortOptions) | undefined) => Promise<void>;
    read: (path: string | import("cids"), options?: (import("./files/read").ReadOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<Uint8Array>;
    ls: (path: string, options?: import("../utils").AbortOptions | undefined) => AsyncIterable<import("./files/ls").UnixFSEntry>;
};
export type Get = (ipfsPath: string | import("cids"), options?: (import("./get").GetOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("../utils").File | import("../utils").Directory>;
export type ID = (_options?: import("../utils").AbortOptions | undefined) => Promise<import("./id").PeerId>;
export type Init = (options?: any) => Promise<{
    add: any;
    addAll: any;
    bitswap: {
        stat: () => Promise<never>;
        unwant: () => Promise<never>;
        wantlist: () => Promise<never>;
        wantlistForPeer: () => Promise<never>;
    };
    bootstrap: {
        add: (multiaddr: import("multiaddr"), options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
        list: (options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
        rm: (multiaddr: import("multiaddr"), options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
    };
    block: any;
    cat: (ipfsPath: string | import("cids"), options?: (import("./cat").CatOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<Uint8Array>;
    config: import("./config").Config;
    dag: any;
    dns: (domain: string, options?: (import("./dns").DNSSettings & import("../utils").AbortOptions) | undefined) => Promise<string>;
    files: import("./files").MFS;
    get: (ipfsPath: string | import("cids"), options?: (import("./get").GetOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("../utils").File | import("../utils").Directory>;
    id: (_options?: import("../utils").AbortOptions | undefined) => Promise<import("./id").PeerId>;
    init: () => Promise<never>;
    isOnline: () => boolean;
    key: {
        export: (name?: any, password?: any, options?: any) => any;
        gen: (name?: any, options?: any) => any;
        import: (name?: any, pem?: any, password?: any, options?: any) => any;
        info: (name?: any, options?: any) => any;
        list: (options?: any) => any;
        rename: (oldName?: any, newName?: any, options?: any) => Promise<{
            was: any;
            now: any;
            id: any;
            overwrite: boolean;
        }>;
        rm: (name?: any, options?: any) => any;
    };
    ls: (ipfsPath: string | import("cids"), options?: (import("./ls").LSOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("../utils").File | import("../utils").Directory>;
    object: any;
    pin: any;
    refs: ((ipfsPath?: any, options?: any) => AsyncGenerator<{
        ref: any;
    }, void, unknown>) & {
        local: (options?: any) => AsyncGenerator<{
            ref: any;
        }, void, any>;
    };
    repo: {
        gc: (_options?: import("../utils").AbortOptions | undefined) => AsyncIterable<import("./repo/gc").Err | import("./repo/gc").BlockID>;
        stat: (options?: any) => Promise<{
            numObjects: any;
            repoSize: any;
            repoPath: any;
            version: any;
            storageMax: any;
        }>;
        version: (options?: any) => Promise<any>;
    };
    resolve: (path: string, opts?: (import("./resolve").ResolveSettings & import("../utils").AbortOptions) | undefined) => Promise<string>;
    start: () => Promise<{
        add: (source: import("ipfs-core-utils/src/files/normalise-input/normalise-input").FileInput, options?: (import("./add").AddOptions & import("../utils").AbortOptions) | undefined) => Promise<import("./add-all").UnixFSEntry>;
        addAll: (source: import("ipfs-core-utils/src/files/normalise-input/normalise-input").Source, options?: (import("./add-all").AddAllOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./add-all").UnixFSEntry>;
        bitswap: {
            stat: (_options?: import("../utils").AbortOptions | undefined) => Promise<import("./bitswap/stat").BitswapStats>;
            unwant: (cids: import("cids") | import("cids")[], options?: import("../utils").AbortOptions | undefined) => Promise<void>;
            wantlist: (options?: import("../utils").AbortOptions | undefined) => Promise<import("cids")[]>;
            wantlistForPeer: (peerId: string | import("cids") | Uint8Array | import("peer-id"), options?: import("../utils").AbortOptions | undefined) => Promise<import("cids")[]>;
        };
        block: Block;
        bootstrap: {
            add: (multiaddr: import("multiaddr"), options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
            clear: (options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
            list: (options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
            reset: (options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
            rm: (multiaddr: import("multiaddr"), options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
        };
        cat: (ipfsPath: string | import("cids"), options?: (import("./cat").CatOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<Uint8Array>;
        config: import("./config").Config;
        dag: DAG;
        dht: {
            get: (key: string | Uint8Array, options?: import("../utils").AbortOptions | undefined) => Promise<Uint8Array>;
            put: (key: Uint8Array, value: Uint8Array, options?: import("../utils").AbortOptions | undefined) => AsyncIterable<import("./dht").QueryEvent>;
            findProvs: (cid: import("cids"), options?: (import("./dht").FindProvsOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./dht").PeerInfo>;
            findPeer: (peerId: import("cids") | import("peer-id"), options?: import("../utils").AbortOptions | undefined) => Promise<{
                id: string;
                addrs: import("multiaddr")[];
            }>;
            provide: (cids: import("cids") | import("cids")[], options?: (import("./dht").ProvideOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./dht").QueryEvent>;
            query: (peerId: string | import("peer-id"), options?: import("../utils").AbortOptions | undefined) => AsyncIterable<{
                id: import("cids");
                addrs: import("multiaddr")[];
            }>;
        } | {
            get: () => Promise<never>;
            put: () => Promise<never>;
            findProvs: () => AsyncGenerator<never, never, unknown>;
            findPeer: () => Promise<never>;
            provide: () => AsyncGenerator<never, never, unknown>;
            query: () => AsyncGenerator<never, never, unknown>;
        };
        dns: (domain: string, options?: (import("./dns").DNSSettings & import("../utils").AbortOptions) | undefined) => Promise<string>;
        files: import("./files").MFS | undefined;
        get: (ipfsPath: string | import("cids"), options?: (import("./get").GetOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("../utils").File | import("../utils").Directory>;
        id: (_options?: import("../utils").AbortOptions | undefined) => Promise<import("./id").PeerId>;
        init: () => Promise<never>;
        isOnline: () => boolean;
        ipld: typeof import(".");
        key: {
            export: (name?: any, password?: any, options?: any) => any;
            gen: (name?: any, options?: any) => any;
            import: (name?: any, pem?: any, password?: any, options?: any) => any;
            info: (name?: any, options?: any) => any;
            list: (options?: any) => any;
            rename: (oldName?: any, newName?: any, options?: any) => Promise<{
                was: any;
                now: any;
                id: any;
                overwrite: boolean;
            }>;
            rm: (name?: any, options?: any) => any;
        };
        libp2p: any;
        ls: (ipfsPath: string | import("cids"), options?: (import("./ls").LSOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("../utils").File | import("../utils").Directory>;
        name: {
            pubsub: {
                cancel: (name: string, options?: import("../utils").AbortOptions | undefined) => Promise<{
                    canceled: boolean;
                }>;
                state: (_options?: import("../utils").AbortOptions | undefined) => Promise<{
                    enabled: boolean;
                }>;
                subs: (options?: import("../utils").AbortOptions | undefined) => Promise<string[]>;
            };
            publish: (value: string, options?: (import("./name/publish").PublishSettings & import("../utils").AbortOptions) | undefined) => Promise<import("./name/publish").PublishResult>;
            resolve: (name: string, options?: (import("./name/resolve").ResolveSettings & import("../utils").AbortOptions) | undefined) => AsyncIterable<string>;
        };
        object: {
            data: (multihash?: any, options?: any) => Promise<any>;
            get: (multihash?: any, options?: any) => Promise<any>;
            links: (multihash?: any, options?: any) => Promise<any>;
            new: (options?: any) => Promise<any>;
            patch: {
                addLink: (multihash?: any, link?: any, options?: any) => Promise<any>;
                appendData: (multihash?: any, data?: any, options?: any) => Promise<any>;
                rmLink: (multihash?: any, linkRef?: any, options?: any) => Promise<any>;
                setData: (multihash?: any, data?: any, options?: any) => Promise<any>;
            };
            put: (obj?: any, options?: any) => Promise<any>;
            stat: (multihash?: any, options?: any) => Promise<{
                Hash: any;
                NumLinks: any;
                BlockSize: any;
                LinksSize: number;
                DataSize: any;
                CumulativeSize: any;
            }>;
        };
        pin: Pin;
        ping: (peerId: import("peer-id"), options?: (import("./ping").PingSettings & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./ping").Pong | import("./ping").PingFailure | import("./ping").StatusUpdate>;
        pubsub: {
            subscribe: (...args: any[]) => any;
            unsubscribe: (...args: any[]) => any;
            publish: (topic?: any, data?: any, _options?: any) => Promise<void>;
            ls: (...args: any[]) => any;
            peers: (...args: any[]) => any;
        };
        refs: ((ipfsPath?: any, options?: any) => AsyncGenerator<{
            ref: any;
        }, void, unknown>) & {
            local: (options?: any) => AsyncGenerator<{
                ref: any;
            }, void, any>;
        };
        repo: {
            gc: (_options?: import("../utils").AbortOptions | undefined) => AsyncIterable<import("./repo/gc").Err | import("./repo/gc").BlockID>;
            stat: (options?: any) => Promise<{
                numObjects: any;
                repoSize: any;
                repoPath: any;
                version: any;
                storageMax: any;
            }>;
            version: (options?: any) => Promise<any>;
        };
        resolve: (path: string, opts?: (import("./resolve").ResolveSettings & import("../utils").AbortOptions) | undefined) => Promise<string>;
        start: () => {};
        stats: {
            bitswap: (_options?: import("../utils").AbortOptions | undefined) => Promise<import("./bitswap/stat").BitswapStats>;
            bw: ((options?: any) => AsyncGenerator<{
                totalIn: any;
                totalOut: any;
                rateIn: import("bignumber.js").default;
                rateOut: import("bignumber.js").default;
            }, void, any>) | (() => Promise<never>);
            repo: (options?: any) => Promise<{
                numObjects: any;
                repoSize: any;
                repoPath: any;
                version: any;
                storageMax: any;
            }>;
        };
        stop: (_options: import("../utils").AbortOptions) => Promise<void>;
        swarm: {
            addrs: (options?: any) => Promise<{
                id: any;
                addrs: any;
            }[]>;
            connect: (addr?: any, options?: any) => any;
            disconnect: (addr?: any, options?: any) => any;
            localAddrs: () => Promise<any>;
            peers: (options?: any) => Promise<{
                addr: any;
                peer: any;
            }[]>;
        };
        version: (options?: import("../utils").AbortOptions | undefined) => Promise<import("./version").Version>;
    }>;
    stats: {
        bitswap: () => Promise<never>;
        bw: () => Promise<never>;
        repo: (options?: any) => Promise<{
            numObjects: any;
            repoSize: any;
            repoPath: any;
            version: any;
            storageMax: any;
        }>;
    };
    stop: () => void;
    swarm: {
        addrs: () => Promise<never>;
        connect: () => Promise<never>;
        disconnect: () => Promise<never>;
        localAddrs: () => Promise<any>;
        peers: () => Promise<never>;
    };
    version: (options?: import("../utils").AbortOptions | undefined) => Promise<import("./version").Version>;
}>;
export type IsOnline = () => boolean;
export type Key = {
    export: ReturnType<typeof import('./key/export')>;
    gen: ReturnType<typeof import('./key/gen')>;
    import: ReturnType<typeof import('./key/import')>;
    info: ReturnType<typeof import('./key/info')>;
    list: ReturnType<typeof import('./key/list')>;
    rename: ReturnType<typeof import('./key/rename')>;
    rm: ReturnType<typeof import('./key/rm')>;
};
export type LibP2P = any;
export type LS = (ipfsPath: string | import("cids"), options?: (import("./ls").LSOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("../utils").File | import("../utils").Directory>;
export type Name = {
    publish: ReturnType<typeof import('./name/publish')>;
    resolve: ReturnType<typeof import('./name/resolve')>;
    pubsub: NamePubSub;
};
export type NamePubSub = {
    cancel: ReturnType<typeof import('./name/pubsub/cancel')>;
    state: ReturnType<typeof import('./name/pubsub/state')>;
    subs: ReturnType<typeof import('./name/pubsub/subs')>;
};
export type ObjectAPI = {
    data: ReturnType<typeof import('./object/data')>;
    get: ReturnType<typeof import('./object/get')>;
    links: ReturnType<typeof import('./object/links')>;
    new: ReturnType<typeof import('./object/new')>;
    put: ReturnType<typeof import('./object/put')>;
    stat: ReturnType<typeof import('./object/stat')>;
    patch: ObjectPath;
};
export type ObjectPath = {
    addLink: ReturnType<typeof import('./object/patch/add-link')>;
    rmLink: ReturnType<typeof import('./object/patch/rm-link')>;
    appendData: ReturnType<typeof import('./object/patch/append-data')>;
    setData: ReturnType<typeof import('./object/patch/set-data')>;
};
export type Pin = {
    add: ReturnType<typeof import("./pin/add")>;
    addAll: ReturnType<typeof import("./pin/add-all")>;
    ls: ReturnType<typeof import("./pin/ls")>;
    rm: ReturnType<typeof import("./pin/rm")>;
};
export type Ping = (peerId: import("peer-id"), options?: (import("./ping").PingSettings & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./ping").Pong | import("./ping").PingFailure | import("./ping").StatusUpdate>;
export type PubSub = {
    subscribe: (...args: any[]) => any;
    unsubscribe: (...args: any[]) => any;
    publish: (topic?: any, data?: any, _options?: any) => Promise<void>;
    ls: (...args: any[]) => any;
    peers: (...args: any[]) => any;
};
export type Refs = (ipfsPath?: any, options?: any) => AsyncGenerator<{
    ref: any;
}, void, unknown>;
export type LocalRefs = (options?: any) => AsyncGenerator<{
    ref: any;
}, void, any>;
export type RefsWithLocal = ((ipfsPath?: any, options?: any) => AsyncGenerator<{
    ref: any;
}, void, unknown>) & {
    local: LocalRefs;
};
export type Repo = {
    gc: ReturnType<typeof import("./repo/gc")>;
    stat: ReturnType<typeof import("./repo/stat")>;
    version: ReturnType<typeof import("./repo/version")>;
};
export type Resolve = (path: string, opts?: (import("./resolve").ResolveSettings & import("../utils").AbortOptions) | undefined) => Promise<string>;
export type Start = () => Promise<{
    add: (source: import("ipfs-core-utils/src/files/normalise-input/normalise-input").FileInput, options?: (import("./add").AddOptions & import("../utils").AbortOptions) | undefined) => Promise<import("./add-all").UnixFSEntry>;
    addAll: (source: import("ipfs-core-utils/src/files/normalise-input/normalise-input").Source, options?: (import("./add-all").AddAllOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./add-all").UnixFSEntry>;
    bitswap: {
        stat: (_options?: import("../utils").AbortOptions | undefined) => Promise<import("./bitswap/stat").BitswapStats>;
        unwant: (cids: import("cids") | import("cids")[], options?: import("../utils").AbortOptions | undefined) => Promise<void>;
        wantlist: (options?: import("../utils").AbortOptions | undefined) => Promise<import("cids")[]>;
        wantlistForPeer: (peerId: string | import("cids") | Uint8Array | import("peer-id"), options?: import("../utils").AbortOptions | undefined) => Promise<import("cids")[]>;
    };
    block: Block;
    bootstrap: {
        add: (multiaddr: import("multiaddr"), options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
        clear: (options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
        list: (options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
        reset: (options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
        rm: (multiaddr: import("multiaddr"), options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
    };
    cat: (ipfsPath: string | import("cids"), options?: (import("./cat").CatOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<Uint8Array>;
    config: import("./config").Config;
    dag: DAG;
    dht: {
        get: (key: string | Uint8Array, options?: import("../utils").AbortOptions | undefined) => Promise<Uint8Array>;
        put: (key: Uint8Array, value: Uint8Array, options?: import("../utils").AbortOptions | undefined) => AsyncIterable<import("./dht").QueryEvent>;
        findProvs: (cid: import("cids"), options?: (import("./dht").FindProvsOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./dht").PeerInfo>;
        findPeer: (peerId: import("cids") | import("peer-id"), options?: import("../utils").AbortOptions | undefined) => Promise<{
            id: string;
            addrs: import("multiaddr")[];
        }>;
        provide: (cids: import("cids") | import("cids")[], options?: (import("./dht").ProvideOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./dht").QueryEvent>;
        query: (peerId: string | import("peer-id"), options?: import("../utils").AbortOptions | undefined) => AsyncIterable<{
            id: import("cids");
            addrs: import("multiaddr")[];
        }>;
    } | {
        get: () => Promise<never>;
        put: () => Promise<never>;
        findProvs: () => AsyncGenerator<never, never, unknown>;
        findPeer: () => Promise<never>;
        provide: () => AsyncGenerator<never, never, unknown>;
        query: () => AsyncGenerator<never, never, unknown>;
    };
    dns: (domain: string, options?: (import("./dns").DNSSettings & import("../utils").AbortOptions) | undefined) => Promise<string>;
    files: import("./files").MFS | undefined;
    get: (ipfsPath: string | import("cids"), options?: (import("./get").GetOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("../utils").File | import("../utils").Directory>;
    id: (_options?: import("../utils").AbortOptions | undefined) => Promise<import("./id").PeerId>;
    init: () => Promise<never>;
    isOnline: () => boolean;
    ipld: typeof import(".");
    key: {
        export: (name?: any, password?: any, options?: any) => any;
        gen: (name?: any, options?: any) => any;
        import: (name?: any, pem?: any, password?: any, options?: any) => any;
        info: (name?: any, options?: any) => any;
        list: (options?: any) => any;
        rename: (oldName?: any, newName?: any, options?: any) => Promise<{
            was: any;
            now: any;
            id: any;
            overwrite: boolean;
        }>;
        rm: (name?: any, options?: any) => any;
    };
    libp2p: any;
    ls: (ipfsPath: string | import("cids"), options?: (import("./ls").LSOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("../utils").File | import("../utils").Directory>;
    name: {
        pubsub: {
            cancel: (name: string, options?: import("../utils").AbortOptions | undefined) => Promise<{
                canceled: boolean;
            }>;
            state: (_options?: import("../utils").AbortOptions | undefined) => Promise<{
                enabled: boolean;
            }>;
            subs: (options?: import("../utils").AbortOptions | undefined) => Promise<string[]>;
        };
        publish: (value: string, options?: (import("./name/publish").PublishSettings & import("../utils").AbortOptions) | undefined) => Promise<import("./name/publish").PublishResult>;
        resolve: (name: string, options?: (import("./name/resolve").ResolveSettings & import("../utils").AbortOptions) | undefined) => AsyncIterable<string>;
    };
    object: {
        data: (multihash?: any, options?: any) => Promise<any>;
        get: (multihash?: any, options?: any) => Promise<any>;
        links: (multihash?: any, options?: any) => Promise<any>;
        new: (options?: any) => Promise<any>;
        patch: {
            addLink: (multihash?: any, link?: any, options?: any) => Promise<any>;
            appendData: (multihash?: any, data?: any, options?: any) => Promise<any>;
            rmLink: (multihash?: any, linkRef?: any, options?: any) => Promise<any>;
            setData: (multihash?: any, data?: any, options?: any) => Promise<any>;
        };
        put: (obj?: any, options?: any) => Promise<any>;
        stat: (multihash?: any, options?: any) => Promise<{
            Hash: any;
            NumLinks: any;
            BlockSize: any;
            LinksSize: number;
            DataSize: any;
            CumulativeSize: any;
        }>;
    };
    pin: Pin;
    ping: (peerId: import("peer-id"), options?: (import("./ping").PingSettings & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./ping").Pong | import("./ping").PingFailure | import("./ping").StatusUpdate>;
    pubsub: {
        subscribe: (...args: any[]) => any;
        unsubscribe: (...args: any[]) => any;
        publish: (topic?: any, data?: any, _options?: any) => Promise<void>;
        ls: (...args: any[]) => any;
        peers: (...args: any[]) => any;
    };
    refs: ((ipfsPath?: any, options?: any) => AsyncGenerator<{
        ref: any;
    }, void, unknown>) & {
        local: (options?: any) => AsyncGenerator<{
            ref: any;
        }, void, any>;
    };
    repo: {
        gc: (_options?: import("../utils").AbortOptions | undefined) => AsyncIterable<import("./repo/gc").Err | import("./repo/gc").BlockID>;
        stat: (options?: any) => Promise<{
            numObjects: any;
            repoSize: any;
            repoPath: any;
            version: any;
            storageMax: any;
        }>;
        version: (options?: any) => Promise<any>;
    };
    resolve: (path: string, opts?: (import("./resolve").ResolveSettings & import("../utils").AbortOptions) | undefined) => Promise<string>;
    start: () => {};
    stats: {
        bitswap: (_options?: import("../utils").AbortOptions | undefined) => Promise<import("./bitswap/stat").BitswapStats>;
        bw: ((options?: any) => AsyncGenerator<{
            totalIn: any;
            totalOut: any;
            rateIn: import("bignumber.js").default;
            rateOut: import("bignumber.js").default;
        }, void, any>) | (() => Promise<never>);
        repo: (options?: any) => Promise<{
            numObjects: any;
            repoSize: any;
            repoPath: any;
            version: any;
            storageMax: any;
        }>;
    };
    stop: (_options: import("../utils").AbortOptions) => Promise<void>;
    swarm: {
        addrs: (options?: any) => Promise<{
            id: any;
            addrs: any;
        }[]>;
        connect: (addr?: any, options?: any) => any;
        disconnect: (addr?: any, options?: any) => any;
        localAddrs: () => Promise<any>;
        peers: (options?: any) => Promise<{
            addr: any;
            peer: any;
        }[]>;
    };
    version: (options?: import("../utils").AbortOptions | undefined) => Promise<import("./version").Version>;
}>;
export type Stats = {
    bw: ReturnType<typeof import('./stats/bw')>;
};
export type Stop = (_options: import("../utils").AbortOptions) => Promise<void>;
export type Swarm = {
    addrs: ReturnType<typeof import('./swarm/addrs')>;
    connect: ReturnType<typeof import('./swarm/connect')>;
    disconnect: ReturnType<typeof import('./swarm/disconnect')>;
    localAddrs: ReturnType<typeof import('./swarm/local-addrs')>;
    peers: ReturnType<typeof import('./swarm/peers')>;
};
export type Version = (options?: import("../utils").AbortOptions | undefined) => Promise<import("./version").Version>;
export type Preload = ((() => void) & {
    start: () => void;
    stop: () => void;
}) | {
    (path: string | import("cids")): Promise<void>;
    start(): void;
    stop(): void;
};
export type GCLock = {
    readLock: () => Promise<Lock>;
    writeLock: () => Promise<Lock>;
};
export type RWLock = {
    readLock: () => Promise<Lock>;
    writeLock: () => Promise<Lock>;
};
/**
 * // External library types
 */
export type Lock = () => void;
export type CID = import("cids");
export type PeerId = import("peer-id");
/**
 * // Justs pretending these things are typed & hopefully in the future they
 * // wil be.
 */
export type Multiaddr = import("multiaddr");
export type IPLD = any;
export type IPLDConfig = any;
export type IPLDBlock = import("ipld-block/src");
export type IPFSRepo = any;
export type IPFSBlockService = any;
export type IPFSBitSwap = any;
export type LibP2PService = any;
export type LibP2PConfig = any;
export type IPFSAPI = {
    add: Add;
    bitswap: BitSwap;
    block: Block;
    bootstrap: Bootstrap;
    cat: Cat;
    config: Config;
    dag: DAG;
    dht: DHT;
    dns: DNS;
    files: Files;
    get: Get;
    id: ID;
    isOnline: IsOnline;
    key: Key;
    libp2p: any;
    ls: LS;
    name: Name;
    object: ObjectAPI;
    pin: Pin;
    ping: Ping;
    pubsub: PubSub;
    refs: Refs;
    repo: Repo;
    resolve: Resolve;
    stats: Stats;
    swarm: Swarm;
    version: Version;
    init: Init;
    start: Start;
    stop: Stop;
};
declare namespace ___Users_alex_Documents_Workspaces_ipfs_js_ipfs_packages_ipfs_core_src_components_index_ { }
export {};
//# sourceMappingURL=index.d.ts.map