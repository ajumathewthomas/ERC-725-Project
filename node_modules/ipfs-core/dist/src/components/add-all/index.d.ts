declare function _exports({ block, gcLock, preload, pin, options: constructorOptions }: {
    block: import('..').Block;
    gcLock: import('..').GCLock;
    preload: import('..').Preload;
    pin: import('..').Pin;
    options: import('../init').ConstructorOptions<any, boolean>;
}): (source: import("ipfs-core-utils/src/files/normalise-input/normalise-input").Source, options?: (AddAllOptions & import("../../utils").AbortOptions) | undefined) => AsyncIterable<UnixFSEntry>;
export = _exports;
export type UnixFSEntry = {
    path: string;
    cid: CID;
    mode?: number | undefined;
    mtime?: import("../../utils").MTime | undefined;
    size: number;
};
export type AddAllOptions = {
    /**
     * - Chunking algorithm used to build
     * ipfs DAGs.
     */
    chunker?: string | undefined;
    /**
     * - The CID version to use when storing the data.
     */
    cidVersion?: 0 | 1 | undefined;
    /**
     * - Allows to create
     * directories with an unlimited number of entries currently size of unixfs
     * directories is limited by the maximum block size. **Note** that this is an
     * experimental feature.
     */
    enableShardingExperiment?: boolean | undefined;
    /**
     * - Multihash hashing algorithm to use.
     */
    hashAlg?: string | undefined;
    /**
     * - If true, will not add blocks to the
     * blockstore.
     */
    onlyHash?: boolean | undefined;
    /**
     * - Pin this object when adding.
     */
    pin?: boolean | undefined;
    /**
     * - a function that will be called with the number of bytes added as a file is added to ipfs and the path of the file being added
     */
    progress?: ((bytes: number, path: string) => void) | undefined;
    /**
     * - If true, DAG leaves will contain raw
     * file data and not be wrapped in a protobuf.
     */
    rawLeaves?: boolean | undefined;
    /**
     * - Directories with more than this
     * number of files will be created as HAMT-sharded directories.
     */
    shardSplitThreshold?: number | undefined;
    /**
     * - If true will use the
     * [trickle DAG](https://godoc.org/github.com/ipsn/go-ipfs/gxlibs/github.com/ipfs/go-unixfs/importer/trickle)
     * format for DAG generation.
     */
    trickle?: boolean | undefined;
    /**
     * - Adds a wrapping node around
     * the content.
     */
    wrapWithDirectory?: boolean | undefined;
};
export type FileStream = Iterable<string | String | AsyncIterable<Uint8Array> | Blob | ArrayBufferView | ArrayBuffer | Iterable<Uint8Array> | ReadableStream<Uint8Array> | import("ipfs-core-utils/src/files/normalise-input/normalise-input").FileInput> | AsyncIterable<string | String | AsyncIterable<Uint8Array> | Blob | ArrayBufferView | ArrayBuffer | Iterable<Uint8Array> | ReadableStream<Uint8Array> | import("ipfs-core-utils/src/files/normalise-input/normalise-input").FileInput> | ReadableStream<string | String | AsyncIterable<Uint8Array> | Blob | ArrayBufferView | ArrayBuffer | Iterable<Uint8Array> | ReadableStream<Uint8Array> | import("ipfs-core-utils/src/files/normalise-input/normalise-input").FileInput>;
export type MTime = {
    /**
     * - the number of seconds since (positive) or before
     * (negative) the Unix Epoch began
     */
    secs: number;
    /**
     * - the number of nanoseconds since the last full
     * second.
     */
    nsecs?: number | undefined;
};
export type AbortOptions = {
    /**
     * - A timeout in ms
     */
    timeout?: number | undefined;
    /**
     * - Can be used to cancel any long running requests started as a result of this call
     */
    signal?: AbortSignal | undefined;
};
export type CID = import("cids");
//# sourceMappingURL=index.d.ts.map