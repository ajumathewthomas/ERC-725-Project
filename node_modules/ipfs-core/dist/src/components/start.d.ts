declare function _exports({ apiManager, options: constructorOptions, blockService, gcLock, initOptions, ipld, keychain, peerId, pinManager, preload, print, repo }: {
    apiManager: APIManager;
    options: StartOptions;
    blockService: IPFSBlockService;
    gcLock: GCLock;
    initOptions: InitOptions;
    ipld: IPLD;
    keychain: Keychain;
    peerId: PeerId;
    pinManager: PinManager;
    preload: Preload;
    print: Print;
    repo: IPFSRepo;
}): () => Promise<{
    add: (source: import("ipfs-core-utils/src/files/normalise-input/normalise-input").FileInput, options?: (import("./add").AddOptions & import("../utils").AbortOptions) | undefined) => Promise<import("./add-all").UnixFSEntry>;
    addAll: (source: import("ipfs-core-utils/src/files/normalise-input/normalise-input").Source, options?: (import("./add-all").AddAllOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./add-all").UnixFSEntry>;
    bitswap: {
        stat: (_options?: import("../utils").AbortOptions | undefined) => Promise<import("./bitswap/stat").BitswapStats>;
        unwant: (cids: import("cids") | import("cids")[], options?: import("../utils").AbortOptions | undefined) => Promise<void>;
        wantlist: (options?: import("../utils").AbortOptions | undefined) => Promise<import("cids")[]>;
        wantlistForPeer: (peerId: string | import("cids") | Uint8Array | import("peer-id"), options?: import("../utils").AbortOptions | undefined) => Promise<import("cids")[]>;
    };
    block: import(".").Block;
    bootstrap: {
        add: (multiaddr: import("multiaddr"), options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
        clear: (options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
        list: (options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
        reset: (options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
        rm: (multiaddr: import("multiaddr"), options?: import("../utils").AbortOptions | undefined) => Promise<import("./bootstrap/utils").Peers>;
    };
    cat: (ipfsPath: string | import("cids"), options?: (import("./cat").CatOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<Uint8Array>;
    config: import("./config").Config;
    dag: import(".").DAG;
    dht: {
        get: (key: string | Uint8Array, options?: import("../utils").AbortOptions | undefined) => Promise<Uint8Array>;
        put: (key: Uint8Array, value: Uint8Array, options?: import("../utils").AbortOptions | undefined) => AsyncIterable<import("./dht").QueryEvent>;
        findProvs: (cid: import("cids"), options?: (import("./dht").FindProvsOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./dht").PeerInfo>;
        findPeer: (peerId: import("cids") | import("peer-id"), options?: import("../utils").AbortOptions | undefined) => Promise<{
            id: string;
            addrs: import("multiaddr")[];
        }>;
        provide: (cids: import("cids") | import("cids")[], options?: (import("./dht").ProvideOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./dht").QueryEvent>;
        query: (peerId: string | import("peer-id"), options?: import("../utils").AbortOptions | undefined) => AsyncIterable<{
            id: import("cids");
            addrs: import("multiaddr")[];
        }>;
    } | {
        get: () => Promise<never>;
        put: () => Promise<never>;
        findProvs: () => AsyncGenerator<never, never, unknown>;
        findPeer: () => Promise<never>;
        provide: () => AsyncGenerator<never, never, unknown>;
        query: () => AsyncGenerator<never, never, unknown>;
    };
    dns: (domain: string, options?: (import("./dns").DNSSettings & import("../utils").AbortOptions) | undefined) => Promise<string>;
    files: import("./files").MFS | undefined;
    get: (ipfsPath: string | import("cids"), options?: (import("./get").GetOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("../utils").File | import("../utils").Directory>;
    id: (_options?: import("../utils").AbortOptions | undefined) => Promise<import("./id").PeerId>;
    init: () => Promise<never>;
    isOnline: () => boolean;
    ipld: typeof import(".");
    key: {
        export: (name?: any, password?: any, options?: any) => any;
        gen: (name?: any, options?: any) => any;
        import: (name?: any, pem?: any, password?: any, options?: any) => any;
        info: (name?: any, options?: any) => any;
        list: (options?: any) => any;
        rename: (oldName?: any, newName?: any, options?: any) => Promise<{
            was: any;
            now: any;
            id: any;
            overwrite: boolean;
        }>;
        rm: (name?: any, options?: any) => any;
    };
    libp2p: any;
    ls: (ipfsPath: string | import("cids"), options?: (import("./ls").LSOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("../utils").File | import("../utils").Directory>;
    name: {
        pubsub: {
            cancel: (name: string, options?: import("../utils").AbortOptions | undefined) => Promise<{
                canceled: boolean;
            }>;
            state: (_options?: import("../utils").AbortOptions | undefined) => Promise<{
                enabled: boolean;
            }>;
            subs: (options?: import("../utils").AbortOptions | undefined) => Promise<string[]>;
        };
        publish: (value: string, options?: (import("./name/publish").PublishSettings & import("../utils").AbortOptions) | undefined) => Promise<import("./name/publish").PublishResult>;
        resolve: (name: string, options?: (import("./name/resolve").ResolveSettings & import("../utils").AbortOptions) | undefined) => AsyncIterable<string>;
    };
    object: {
        data: (multihash?: any, options?: any) => Promise<any>;
        get: (multihash?: any, options?: any) => Promise<any>;
        links: (multihash?: any, options?: any) => Promise<any>;
        new: (options?: any) => Promise<any>;
        patch: {
            addLink: (multihash?: any, link?: any, options?: any) => Promise<any>;
            appendData: (multihash?: any, data?: any, options?: any) => Promise<any>;
            rmLink: (multihash?: any, linkRef?: any, options?: any) => Promise<any>;
            setData: (multihash?: any, data?: any, options?: any) => Promise<any>;
        };
        put: (obj?: any, options?: any) => Promise<any>;
        stat: (multihash?: any, options?: any) => Promise<{
            Hash: any;
            NumLinks: any;
            BlockSize: any;
            LinksSize: number;
            DataSize: any;
            CumulativeSize: any;
        }>;
    };
    pin: import(".").Pin;
    ping: (peerId: import("peer-id"), options?: (import("./ping").PingSettings & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./ping").Pong | import("./ping").PingFailure | import("./ping").StatusUpdate>;
    pubsub: {
        subscribe: (...args: any[]) => any;
        unsubscribe: (...args: any[]) => any;
        publish: (topic?: any, data?: any, _options?: any) => Promise<void>;
        ls: (...args: any[]) => any;
        peers: (...args: any[]) => any;
    };
    refs: ((ipfsPath?: any, options?: any) => AsyncGenerator<{
        ref: any;
    }, void, unknown>) & {
        local: (options?: any) => AsyncGenerator<{
            ref: any;
        }, void, any>;
    };
    repo: {
        gc: (_options?: import("../utils").AbortOptions | undefined) => AsyncIterable<import("./repo/gc").Err | import("./repo/gc").BlockID>;
        stat: (options?: any) => Promise<{
            numObjects: any;
            repoSize: any;
            repoPath: any;
            version: any;
            storageMax: any;
        }>;
        version: (options?: any) => Promise<any>;
    };
    resolve: (path: string, opts?: (import("./resolve").ResolveSettings & import("../utils").AbortOptions) | undefined) => Promise<string>;
    start: () => {};
    stats: {
        bitswap: (_options?: import("../utils").AbortOptions | undefined) => Promise<import("./bitswap/stat").BitswapStats>;
        bw: ((options?: any) => AsyncGenerator<{
            totalIn: any;
            totalOut: any;
            rateIn: import("bignumber.js").default;
            rateOut: import("bignumber.js").default;
        }, void, any>) | (() => Promise<never>);
        repo: (options?: any) => Promise<{
            numObjects: any;
            repoSize: any;
            repoPath: any;
            version: any;
            storageMax: any;
        }>;
    };
    stop: (_options: import("../utils").AbortOptions) => Promise<void>;
    swarm: {
        addrs: (options?: any) => Promise<{
            id: any;
            addrs: any;
        }[]>;
        connect: (addr?: any, options?: any) => any;
        disconnect: (addr?: any, options?: any) => any;
        localAddrs: () => Promise<any>;
        peers: (options?: any) => Promise<{
            addr: any;
            peer: any;
        }[]>;
    };
    version: (options?: import("../utils").AbortOptions | undefined) => Promise<import("./version").Version>;
}>;
export = _exports;
export type CreateAPIConfig = {
    apiManager: APIManager;
    bitswap?: any;
    block: Block;
    blockService: any;
    config: Config;
    constructorOptions: StartOptions;
    dag: DAG;
    files?: import("./files").MFS | undefined;
    gcLock: GCLock;
    initOptions: InitOptions;
    ipld: IPLD;
    ipns: import('../ipns');
    keychain: any;
    libp2p: any;
    mfsPreload: MFSPreload;
    peerId: PeerId;
    pin: Pin;
    preload: Preload;
    print: Print;
    repo: any;
};
export type Print = (...args: any[]) => void;
export type InitOptions = {
    /**
     * - Whether to remove built-in assets,
     * like the instructional tour and empty mutable file system, from the repo.
     */
    emptyRepo?: boolean | undefined;
    /**
     * - Number of bits to use in the generated key
     * pair (rsa only).
     */
    bits?: number | undefined;
    /**
     * - A pre-generated private key to use.
     * **NOTE: This overrides `bits`.**
     */
    privateKey?: string | import("peer-id") | undefined;
    /**
     * - A passphrase to encrypt keys. You should
     * generally use the top-level `pass` option instead of the `init.pass`
     * option (this one will take its value from the top-level option if not set).
     */
    pass?: string | undefined;
    /**
     * - Apply profile settings to config.
     */
    profiles?: string[] | undefined;
    /**
     * - Set to `false` to disallow
     * initialization if the repo does not already exist.
     */
    allowNew?: boolean | undefined;
    config?: import("./config").IPFSConfig | undefined;
};
export type StartOptions = {
    repo?: any;
    /**
     * - `js-ipfs` comes bundled with a
     * tool that automatically migrates your IPFS repository when a new version is
     * available.
     */
    repoAutoMigrate?: boolean | undefined;
    /**
     * - Perform repo initialization steps when creating
     * the IPFS node.
     * Note that *initializing* a repo is different from creating an instance of
     * [`ipfs.Repo`](https://github.com/ipfs/js-ipfs-repo). The IPFS constructor
     * sets many special properties when initializing a repo, so you should usually
     * not try and call `repoInstance.init()` yourself.
     */
    init?: boolean | import("./init").InitOptions | undefined;
    /**
     * - If `false`, do not automatically
     * start the IPFS node. Instead, you’ll need to manually call
     * [`node.start()`](https://github.com/ipfs/js-ipfs/blob/master/packages/ipfs/docs/MODULE.md#nodestart)
     * yourself.
     */
    start?: true | undefined;
    /**
     * - A passphrase to encrypt/decrypt your keys.
     */
    pass?: string | undefined;
    /**
     * - Prevents all logging output from the
     * IPFS node. (Default: `false`)
     */
    silent?: boolean | undefined;
    /**
     * - Configure circuit relay (see the [circuit relay tutorial]
     * (https://github.com/ipfs/js-ipfs/tree/master/examples/circuit-relaying)
     * to learn more).
     */
    relay?: import("./init").RelayOptions | undefined;
    /**
     * - Run ipfs node offline. The node does
     * not connect to the rest of the network but provides a local API.
     */
    offline?: boolean | undefined;
    /**
     * - Configure remote preload nodes.
     * The remote will preload content added on this node, and also attempt to
     * preload objects requested by this node.
     */
    preload?: import("./init").PreloadOptions | undefined;
    /**
     * - Enable and configure
     * experimental features.
     */
    EXPERIMENTAL?: import("./init").ExperimentalOptions | undefined;
    /**
     * - Modify the default IPFS node config. This
     * object will be *merged* with the default config; it will not replace it.
     * (Default: [`config-nodejs.js`](https://github.com/ipfs/js-ipfs/tree/master/packages/ipfs/src/core/runtime/config-nodejs.js)
     * in Node.js, [`config-browser.js`](https://github.com/ipfs/js-ipfs/tree/master/packages/ipfs/src/core/runtime/config-browser.js)
     * in browsers)
     */
    config?: any;
    /**
     * - Modify the default IPLD config. This object
     * will be *merged* with the default config; it will not replace it. Check IPLD
     * [docs](https://github.com/ipld/js-ipld#ipld-constructor) for more information
     * on the available options. (Default: [`ipld.js`]
     * (https://github.com/ipfs/js-ipfs/tree/master/packages/ipfs/src/core/runtime/ipld.js)
     * in browsers)
     */
    ipld?: any;
    /**
     * - The libp2p option allows you to build
     * your libp2p node by configuration, or via a bundle function. If you are
     * looking to just modify the below options, using the object format is the
     * quickest way to get the default features of libp2p. If you need to create a
     * more customized libp2p node, such as with custom transports or peer/content
     * routers that need some of the ipfs data on startup, a custom bundle is a
     * great way to achieve this.
     * - You can see the bundle in action in the [custom libp2p example](https://github.com/ipfs/js-ipfs/tree/master/examples/custom-libp2p).
     * - Please see [libp2p/docs/CONFIGURATION.md](https://github.com/libp2p/js-libp2p/blob/master/doc/CONFIGURATION.md)
     * for the list of options libp2p supports.
     * - Default: [`libp2p-nodejs.js`](../src/core/runtime/libp2p-nodejs.js)
     * in Node.js, [`libp2p-browser.js`](../src/core/runtime/libp2p-browser.js) in
     * browsers.
     */
    libp2p?: any;
    repoOwner?: boolean | undefined;
};
export type Keychain = any;
export type APIManager = import("../api-manager");
export type PinManager = import("./pin/pin-manager");
export type MFSPreload = {
    start(): Promise<void>;
    stop(): void;
};
export type IPFSBlockService = any;
export type GCLock = {
    readLock: () => Promise<() => void>;
    writeLock: () => Promise<() => void>;
};
export type IPLD = typeof import(".");
export type PeerId = import("peer-id");
export type Preload = ((() => void) & {
    start: () => void;
    stop: () => void;
}) | {
    (path: string | import("cids")): Promise<void>;
    start(): void;
    stop(): void;
};
export type IPFSRepo = any;
export type LibP2P = any;
export type Pin = {
    add: (path: string | import("cids"), options?: (import("./pin/add").AddOptions & import("../utils").AbortOptions) | undefined) => Promise<import("cids")>;
    addAll: (source: import("ipfs-core-utils/src/pins/normalise-input").Source, options?: (import("./pin/add-all").AddSettings & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("cids")>;
    ls: (options?: (import("./pin/ls").LsSettings & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./pin/ls").LsEntry>;
    rm: (path: string | import("cids"), options?: (import("./pin/rm").RmSettings & import("../utils").AbortOptions) | undefined) => Promise<import("cids")>;
};
export type Files = {
    stat: (path: string, options?: (import("./files/stat").StatOptions & import("../utils").AbortOptions) | undefined) => Promise<import("./files/stat").Stat>;
    chmod: (path: string, mode: string | number, options?: (import("./files/chmod").ChmodOptions & import("../utils").AbortOptions) | undefined) => Promise<void>;
    cp: (...args: [string | import("cids"), (import("./files/cp").CpOptions | undefined)?] | [string | import("cids"), string | import("cids"), (import("./files/cp").CpOptions | undefined)?] | [string | import("cids"), string | import("cids"), string | import("cids"), (import("./files/cp").CpOptions | undefined)?] | [string | import("cids"), string | import("cids"), string | import("cids"), string | import("cids"), (import("./files/cp").CpOptions | undefined)?] | [string | import("cids"), string | import("cids"), string | import("cids"), string | import("cids"), string | import("cids"), (import("./files/cp").CpOptions | undefined)?] | [string | import("cids"), string | import("cids"), string | import("cids"), string | import("cids"), string | import("cids"), string | import("cids"), (import("./files/cp").CpOptions | undefined)?] | [string | import("cids"), string | import("cids"), string | import("cids"), string | import("cids"), string | import("cids"), string | import("cids"), string | import("cids"), (import("./files/cp").CpOptions | undefined)?] | [string | import("cids"), string | import("cids"), string | import("cids"), string | import("cids"), string | import("cids"), string | import("cids"), string | import("cids"), string | import("cids"), (import("./files/cp").CpOptions | undefined)?]) => Promise<void>;
    flush: (path: string, options?: import("../utils").AbortOptions | undefined) => Promise<import("cids")>;
    mkdir: (path: string, options?: (import("./files/mkdir").MkdirOptions & import("../utils").AbortOptions) | undefined) => Promise<void>;
    mv: (...args: [string, string, (import("./files/mv").MvOptions | undefined)?] | [string, string, string, (import("./files/mv").MvOptions | undefined)?] | [string, string, string, string, (import("./files/mv").MvOptions | undefined)?] | [string, string, string, string, string, (import("./files/mv").MvOptions | undefined)?] | [string, string, string, string, string, string, (import("./files/mv").MvOptions | undefined)?] | [string, string, string, string, string, string, string, (import("./files/mv").MvOptions | undefined)?] | [string, string, string, string, string, string, string, string, (import("./files/mv").MvOptions | undefined)?] | [string, string, string, string, string, string, string, string, string, (import("./files/mv").MvOptions | undefined)?]) => Promise<void>;
    rm: (...args: [string, (import("./files/rm").RmOptions | undefined)?] | [string, string, (import("./files/rm").RmOptions | undefined)?] | [string, string, string, (import("./files/rm").RmOptions | undefined)?] | [string, string, string, string, (import("./files/rm").RmOptions | undefined)?] | [string, string, string, string, string, (import("./files/rm").RmOptions | undefined)?] | [string, string, string, string, string, string, (import("./files/rm").RmOptions | undefined)?] | [string, string, string, string, string, string, string, (import("./files/rm").RmOptions | undefined)?] | [string, string, string, string, string, string, string, string, (import("./files/rm").RmOptions | undefined)?]) => Promise<void>;
    touch: (path: string, options?: (import("./files/touch").TouchOptions & import("../utils").AbortOptions) | undefined) => Promise<void>;
    write: (path: string, content: string | Uint8Array | AsyncIterable<Uint8Array> | Blob, options?: (import("./files/write").WriteOptions & import("../utils").AbortOptions) | undefined) => Promise<void>;
    read: (path: string | import("cids"), options?: (import("./files/read").ReadOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<Uint8Array>;
    ls: (path: string, options?: import("../utils").AbortOptions | undefined) => AsyncIterable<import("./files/ls").UnixFSEntry>;
};
export type DAG = {
    get: (ipfsPath: import("cids"), options?: (import("./dag/get").GetOptions & import("../utils").AbortOptions) | undefined) => Promise<import("./dag/get").DagEntry>;
    put: (dagNode: any, options?: (import("./dag/put").PutOptions & import("../utils").AbortOptions) | undefined) => Promise<import("cids")>;
    resolve: (ipfsPath: string | import("cids"), options?: (import("./dag/resolve").ResolveOptions & import("../utils").AbortOptions) | undefined) => Promise<import("./dag/resolve").ResolveResult>;
    tree: (ipfsPath: import("cids"), options?: (import("./dag/tree").TreeOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<string>;
};
export type Config = {
    get: import("./config").Get;
    getAll: import("./config").GetAll;
    set: import("./config").Set;
    replace: import("./config").Replace;
    profiles: import("./config").Profiles;
};
export type Block = {
    get: (cid: string | import("cids") | Uint8Array, options?: (import("./block/get").GetOptions & import("../utils").AbortOptions) | undefined) => Promise<import("ipld-block/src")>;
    put: (block: Uint8Array | import("ipld-block/src"), options?: (import("./block/put").PutOptions & import("../utils").AbortOptions) | undefined) => Promise<import("ipld-block/src")>;
    rm: (cids: import("cids") | import("cids")[], options?: (import("./block/rm").RmOptions & import("../utils").AbortOptions) | undefined) => AsyncIterable<import("./block/rm").RmSucceess | import("./block/rm").RmFailure>;
    stat: (cid: import("cids"), options?: (import("./block/stat").StatOptions & import("../utils").AbortOptions) | undefined) => Promise<import("./block/stat").Stat>;
};
//# sourceMappingURL=start.d.ts.map