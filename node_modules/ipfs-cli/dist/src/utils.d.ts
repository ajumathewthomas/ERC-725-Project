export function getIpfs(argv: any): Promise<{
    isDaemon: boolean;
    ipfs: {
        add: any;
        addAll: any;
        bitswap: {
            stat: () => Promise<never>;
            unwant: () => Promise<never>;
            wantlist: () => Promise<never>;
            wantlistForPeer: () => Promise<never>;
        };
        bootstrap: {
            add: (multiaddr: import("multiaddr"), options?: import("ipfs-core/src/utils").AbortOptions | undefined) => Promise<import("ipfs-core/src/components/bootstrap/utils").Peers>;
            list: (options?: import("ipfs-core/src/utils").AbortOptions | undefined) => Promise<import("ipfs-core/src/components/bootstrap/utils").Peers>;
            rm: (multiaddr: import("multiaddr"), options?: import("ipfs-core/src/utils").AbortOptions | undefined) => Promise<import("ipfs-core/src/components/bootstrap/utils").Peers>;
        };
        block: any;
        cat: (ipfsPath: string | import("cids"), options?: (import("ipfs-core/src/components/cat").CatOptions & import("ipfs-core/src/utils").AbortOptions) | undefined) => AsyncIterable<Uint8Array>;
        config: import("ipfs-core/src/components/config").Config;
        dag: any;
        dns: (domain: string, options?: (import("ipfs-core/src/components/dns").DNSSettings & import("ipfs-core/src/utils").AbortOptions) | undefined) => Promise<string>;
        files: import("ipfs-core/src/components/files").MFS;
        get: (ipfsPath: string | import("cids"), options?: (import("ipfs-core/src/components/get").GetOptions & import("ipfs-core/src/utils").AbortOptions) | undefined) => AsyncIterable<import("ipfs-core/src/utils").File | import("ipfs-core/src/utils").Directory>;
        id: (_options?: import("ipfs-core/src/utils").AbortOptions | undefined) => Promise<import("ipfs-core/src/components/id").PeerId>;
        init: () => Promise<never>;
        isOnline: () => boolean;
        key: {
            export: (name?: any, password?: any, options?: any) => any;
            gen: (name?: any, options?: any) => any;
            import: (name?: any, pem?: any, password?: any, options?: any) => any;
            info: (name?: any, options?: any) => any;
            list: (options?: any) => any;
            rename: (oldName?: any, newName?: any, options?: any) => Promise<{
                was: any;
                now: any;
                id: any;
                overwrite: boolean;
            }>;
            rm: (name?: any, options?: any) => any;
        };
        ls: (ipfsPath: string | import("cids"), options?: (import("ipfs-core/src/components/ls").LSOptions & import("ipfs-core/src/utils").AbortOptions) | undefined) => AsyncIterable<import("ipfs-core/src/utils").File | import("ipfs-core/src/utils").Directory>;
        object: any;
        pin: any;
        refs: ((ipfsPath?: any, options?: any) => AsyncGenerator<{
            ref: any;
        }, void, unknown>) & {
            local: (options?: any) => AsyncGenerator<{
                ref: any;
            }, void, any>;
        };
        repo: {
            gc: (_options?: import("ipfs-core/src/utils").AbortOptions | undefined) => AsyncIterable<import("ipfs-core/src/components/repo/gc").Err | import("ipfs-core/src/components/repo/gc").BlockID>;
            stat: (options?: any) => Promise<{
                numObjects: any;
                repoSize: any;
                repoPath: any;
                version: any;
                storageMax: any;
            }>;
            version: (options?: any) => Promise<any>;
        };
        resolve: (path: string, opts?: (import("ipfs-core/src/components/resolve").ResolveSettings & import("ipfs-core/src/utils").AbortOptions) | undefined) => Promise<string>;
        start: () => Promise<{
            add: (source: import("ipfs-core-utils/src/files/normalise-input/normalise-input").FileInput, options?: (import("ipfs-core/src/components/add").AddOptions & import("ipfs-core/src/utils").AbortOptions) | undefined) => Promise<import("ipfs-core/src/components/add-all").UnixFSEntry>;
            addAll: (source: import("ipfs-core-utils/src/files/normalise-input/normalise-input").Source, options?: (import("ipfs-core/src/components/add-all").AddAllOptions & import("ipfs-core/src/utils").AbortOptions) | undefined) => AsyncIterable<import("ipfs-core/src/components/add-all").UnixFSEntry>;
            bitswap: {
                stat: (_options?: import("ipfs-core/src/utils").AbortOptions | undefined) => Promise<import("ipfs-core/src/components/bitswap/stat").BitswapStats>;
                unwant: (cids: import("cids") | import("cids")[], options?: import("ipfs-core/src/utils").AbortOptions | undefined) => Promise<void>;
                wantlist: (options?: import("ipfs-core/src/utils").AbortOptions | undefined) => Promise<import("cids")[]>;
                wantlistForPeer: (peerId: string | Uint8Array | import("cids") | import("peer-id"), options?: import("ipfs-core/src/utils").AbortOptions | undefined) => Promise<import("cids")[]>;
            };
            block: import("ipfs-core/src/components").Block;
            bootstrap: {
                add: (multiaddr: import("multiaddr"), options?: import("ipfs-core/src/utils").AbortOptions | undefined) => Promise<import("ipfs-core/src/components/bootstrap/utils").Peers>;
                clear: (options?: import("ipfs-core/src/utils").AbortOptions | undefined) => Promise<import("ipfs-core/src/components/bootstrap/utils").Peers>;
                list: (options?: import("ipfs-core/src/utils").AbortOptions | undefined) => Promise<import("ipfs-core/src/components/bootstrap/utils").Peers>;
                reset: (options?: import("ipfs-core/src/utils").AbortOptions | undefined) => Promise<import("ipfs-core/src/components/bootstrap/utils").Peers>;
                rm: (multiaddr: import("multiaddr"), options?: import("ipfs-core/src/utils").AbortOptions | undefined) => Promise<import("ipfs-core/src/components/bootstrap/utils").Peers>;
            };
            cat: (ipfsPath: string | import("cids"), options?: (import("ipfs-core/src/components/cat").CatOptions & import("ipfs-core/src/utils").AbortOptions) | undefined) => AsyncIterable<Uint8Array>;
            config: import("ipfs-core/src/components/config").Config;
            dag: import("ipfs-core/src/components").DAG;
            dht: {
                get: (key: string | Uint8Array, options?: import("ipfs-core/src/utils").AbortOptions | undefined) => Promise<Uint8Array>;
                put: (key: Uint8Array, value: Uint8Array, options?: import("ipfs-core/src/utils").AbortOptions | undefined) => AsyncIterable<import("ipfs-core/src/components/dht").QueryEvent>;
                findProvs: (cid: import("cids"), options?: (import("ipfs-core/src/components/dht").FindProvsOptions & import("ipfs-core/src/utils").AbortOptions) | undefined) => AsyncIterable<import("ipfs-core/src/components/dht").PeerInfo>;
                findPeer: (peerId: import("cids") | import("peer-id"), options?: import("ipfs-core/src/utils").AbortOptions | undefined) => Promise<{
                    id: string;
                    addrs: import("multiaddr")[];
                }>;
                provide: (cids: import("cids") | import("cids")[], options?: (import("ipfs-core/src/components/dht").ProvideOptions & import("ipfs-core/src/utils").AbortOptions) | undefined) => AsyncIterable<import("ipfs-core/src/components/dht").QueryEvent>;
                query: (peerId: string | import("peer-id"), options?: import("ipfs-core/src/utils").AbortOptions | undefined) => AsyncIterable<{
                    id: import("cids");
                    addrs: import("multiaddr")[];
                }>;
            } | {
                get: () => Promise<never>;
                put: () => Promise<never>;
                findProvs: () => AsyncGenerator<never, never, unknown>;
                findPeer: () => Promise<never>;
                provide: () => AsyncGenerator<never, never, unknown>;
                query: () => AsyncGenerator<never, never, unknown>;
            };
            dns: (domain: string, options?: (import("ipfs-core/src/components/dns").DNSSettings & import("ipfs-core/src/utils").AbortOptions) | undefined) => Promise<string>;
            files: import("ipfs-core/src/components/files").MFS | undefined;
            get: (ipfsPath: string | import("cids"), options?: (import("ipfs-core/src/components/get").GetOptions & import("ipfs-core/src/utils").AbortOptions) | undefined) => AsyncIterable<import("ipfs-core/src/utils").File | import("ipfs-core/src/utils").Directory>;
            id: (_options?: import("ipfs-core/src/utils").AbortOptions | undefined) => Promise<import("ipfs-core/src/components/id").PeerId>;
            init: () => Promise<never>;
            isOnline: () => boolean;
            ipld: typeof import("ipfs-core/src/components");
            key: {
                export: (name?: any, password?: any, options?: any) => any;
                gen: (name?: any, options?: any) => any;
                import: (name?: any, pem?: any, password?: any, options?: any) => any;
                info: (name?: any, options?: any) => any;
                list: (options?: any) => any;
                rename: (oldName?: any, newName?: any, options?: any) => Promise<{
                    was: any;
                    now: any;
                    id: any;
                    overwrite: boolean;
                }>;
                rm: (name?: any, options?: any) => any;
            };
            libp2p: any;
            ls: (ipfsPath: string | import("cids"), options?: (import("ipfs-core/src/components/ls").LSOptions & import("ipfs-core/src/utils").AbortOptions) | undefined) => AsyncIterable<import("ipfs-core/src/utils").File | import("ipfs-core/src/utils").Directory>;
            name: {
                pubsub: {
                    cancel: (name: string, options?: import("ipfs-core/src/utils").AbortOptions | undefined) => Promise<{
                        canceled: boolean;
                    }>;
                    state: (_options?: import("ipfs-core/src/utils").AbortOptions | undefined) => Promise<{
                        enabled: boolean;
                    }>;
                    subs: (options?: import("ipfs-core/src/utils").AbortOptions | undefined) => Promise<string[]>;
                };
                publish: (value: string, options?: (import("ipfs-core/src/components/name/publish").PublishSettings & import("ipfs-core/src/utils").AbortOptions) | undefined) => Promise<import("ipfs-core/src/components/name/publish").PublishResult>;
                resolve: (name: string, options?: (import("ipfs-core/src/components/name/resolve").ResolveSettings & import("ipfs-core/src/utils").AbortOptions) | undefined) => AsyncIterable<string>;
            };
            object: {
                data: (multihash?: any, options?: any) => Promise<any>;
                get: (multihash?: any, options?: any) => Promise<any>;
                links: (multihash?: any, options?: any) => Promise<any>;
                new: (options?: any) => Promise<any>;
                patch: {
                    addLink: (multihash?: any, link?: any, options?: any) => Promise<any>;
                    appendData: (multihash?: any, data?: any, options?: any) => Promise<any>;
                    rmLink: (multihash?: any, linkRef?: any, options?: any) => Promise<any>;
                    setData: (multihash?: any, data?: any, options?: any) => Promise<any>;
                };
                put: (obj?: any, options?: any) => Promise<any>;
                stat: (multihash?: any, options?: any) => Promise<{
                    Hash: any;
                    NumLinks: any;
                    BlockSize: any;
                    LinksSize: number;
                    DataSize: any;
                    CumulativeSize: any;
                }>;
            };
            pin: import("ipfs-core/src/components").Pin;
            ping: (peerId: import("peer-id"), options?: (import("ipfs-core/src/components/ping").PingSettings & import("ipfs-core/src/utils").AbortOptions) | undefined) => AsyncIterable<import("ipfs-core/src/components/ping").Pong | import("ipfs-core/src/components/ping").PingFailure | import("ipfs-core/src/components/ping").StatusUpdate>;
            pubsub: {
                subscribe: (...args: any[]) => any;
                unsubscribe: (...args: any[]) => any;
                publish: (topic?: any, data?: any, _options?: any) => Promise<void>;
                ls: (...args: any[]) => any;
                peers: (...args: any[]) => any;
            };
            refs: ((ipfsPath?: any, options?: any) => AsyncGenerator<{
                ref: any;
            }, void, unknown>) & {
                local: (options?: any) => AsyncGenerator<{
                    ref: any;
                }, void, any>;
            };
            repo: {
                gc: (_options?: import("ipfs-core/src/utils").AbortOptions | undefined) => AsyncIterable<import("ipfs-core/src/components/repo/gc").Err | import("ipfs-core/src/components/repo/gc").BlockID>;
                stat: (options?: any) => Promise<{
                    numObjects: any;
                    repoSize: any;
                    repoPath: any;
                    version: any;
                    storageMax: any;
                }>;
                version: (options?: any) => Promise<any>;
            };
            resolve: (path: string, opts?: (import("ipfs-core/src/components/resolve").ResolveSettings & import("ipfs-core/src/utils").AbortOptions) | undefined) => Promise<string>;
            start: () => {};
            stats: {
                bitswap: (_options?: import("ipfs-core/src/utils").AbortOptions | undefined) => Promise<import("ipfs-core/src/components/bitswap/stat").BitswapStats>;
                bw: ((options?: any) => AsyncGenerator<{
                    totalIn: any;
                    totalOut: any;
                    rateIn: import("bignumber.js").default;
                    rateOut: import("bignumber.js").default;
                }, void, any>) | (() => Promise<never>);
                repo: (options?: any) => Promise<{
                    numObjects: any;
                    repoSize: any;
                    repoPath: any;
                    version: any;
                    storageMax: any;
                }>;
            };
            stop: (_options: import("ipfs-core/src/utils").AbortOptions) => Promise<void>;
            swarm: {
                addrs: (options?: any) => Promise<{
                    id: any;
                    addrs: any;
                }[]>;
                connect: (addr?: any, options?: any) => any;
                disconnect: (addr?: any, options?: any) => any;
                localAddrs: () => Promise<any>;
                peers: (options?: any) => Promise<{
                    addr: any;
                    peer: any;
                }[]>;
            };
            version: (options?: import("ipfs-core/src/utils").AbortOptions | undefined) => Promise<import("ipfs-core/src/components/version").Version>;
        }>;
        stats: {
            bitswap: () => Promise<never>;
            bw: () => Promise<never>;
            repo: (options?: any) => Promise<{
                numObjects: any;
                repoSize: any;
                repoPath: any;
                version: any;
                storageMax: any;
            }>;
        };
        stop: () => void;
        swarm: {
            addrs: () => Promise<never>;
            connect: () => Promise<never>;
            disconnect: () => Promise<never>;
            localAddrs: () => Promise<any>;
            peers: () => Promise<never>;
        };
        version: (options?: import("ipfs-core/src/utils").AbortOptions | undefined) => Promise<import("ipfs-core/src/components/version").Version>;
    };
    cleanup: () => Promise<void>;
} | {
    isDaemon: boolean;
    ipfs: {
        add: (input: import("ipfs-core/src/components/add").Source, options?: (import("ipfs-core/src/components/add").AddOptions & import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => Promise<import("ipfs-core/src/components/add-all").UnixFSEntry>;
        addAll: (source: import("ipfs-core-utils/src/files/normalise-input/normalise-input").Source, options?: (import("ipfs-core/src/components/add-all").AddAllOptions & import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => AsyncIterable<import("ipfs-core/src/components/add-all").UnixFSEntry>;
        bitswap: {
            wantlist: (options?: (import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => Promise<import("cids")[]>;
            wantlistForPeer: (peerId: string | Uint8Array | import("cids") | import("peer-id"), options?: (import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => Promise<import("cids")[]>;
            stat: (options?: (import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => Promise<import("ipfs-core/src/components/bitswap/stat").BitswapStats>;
            unwant: (cid: import("cids") | import("cids")[], options?: (import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => Promise<void>;
        };
        block: {
            get: (cid: string | Uint8Array | import("cids"), options?: (import("ipfs-core/src/components/block/get").GetOptions & import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => Promise<any>;
            stat: (cid: import("cids"), options?: (import("ipfs-core/src/components/block/stat").StatOptions & import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => Promise<import("ipfs-core/src/components/block/stat").Stat>;
            put: (data: any, options?: (import("ipfs-core/src/components/block/put").PutOptions & import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => Promise<any>;
            rm: (cid: import("cids") | import("cids")[], options?: (import("ipfs-core/src/components/block/rm").RmOptions & import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => AsyncIterable<import("ipfs-core/src/components/block/rm").RmSucceess | import("ipfs-core/src/components/block/rm").RmFailure>;
        };
        bootstrap: {
            add: (addr: import("multiaddr"), options?: (import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => Promise<import("ipfs-core/src/components/bootstrap/utils").Peers>;
            clear: (options?: (import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => Promise<import("ipfs-core/src/components/bootstrap/utils").Peers>;
            rm: (addr: import("multiaddr"), options?: (import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => Promise<import("ipfs-core/src/components/bootstrap/utils").Peers>;
            reset: (options?: (import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => Promise<import("ipfs-core/src/components/bootstrap/utils").Peers>;
            list: (options?: (import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => Promise<import("ipfs-core/src/components/bootstrap/utils").Peers>;
        };
        cat: (path: string | import("cids"), options?: (import("ipfs-core/src/components/cat").CatOptions & import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => AsyncIterable<Uint8Array>;
        commands: (options?: {} | undefined) => Promise<any>;
        config: {
            getAll: import("../../ipfs-http-client/dist/src/interface").APIWithExtraOptions<import("ipfs-core/src/components/config").GetAll, import("../../ipfs-http-client/dist/src").HttpOptions>;
            get: import("../../ipfs-http-client/dist/src/interface").APIWithExtraOptions<import("ipfs-core/src/components/config").Get, import("../../ipfs-http-client/dist/src").HttpOptions>;
            set: import("../../ipfs-http-client/dist/src/interface").APIWithExtraOptions<import("ipfs-core/src/components/config").Set, import("../../ipfs-http-client/dist/src").HttpOptions>;
            replace: import("../../ipfs-http-client/dist/src/interface").APIWithExtraOptions<import("ipfs-core/src/components/config").Replace, import("../../ipfs-http-client/dist/src").HttpOptions>;
            profiles: {
                apply: (profile: any, options?: {} | undefined) => Promise<{
                    original: any;
                    updated: any;
                }>;
                list: (options?: {} | undefined) => Promise<any>;
            };
        };
        dag: {
            get: import("../../ipfs-http-client/dist/src/interface").APIWithExtraOptions<(ipfsPath: import("cids"), options?: (import("ipfs-core/src/components/dag/get").GetOptions & import("ipfs-core/src/utils").AbortOptions) | undefined) => Promise<import("ipfs-core/src/components/dag/get").DagEntry>, import("../../ipfs-http-client/dist/src").HttpOptions>;
            put: import("../../ipfs-http-client/dist/src/interface").APIWithExtraOptions<(dagNode: any, options?: (import("ipfs-core/src/components/dag/put").PutOptions & import("ipfs-core/src/utils").AbortOptions) | undefined) => Promise<import("cids")>, import("../../ipfs-http-client/dist/src").HttpOptions>;
            resolve: import("../../ipfs-http-client/dist/src/interface").APIWithExtraOptions<(ipfsPath: string | import("cids"), options?: (import("ipfs-core/src/components/dag/resolve").ResolveOptions & import("ipfs-core/src/utils").AbortOptions) | undefined) => Promise<import("ipfs-core/src/components/dag/resolve").ResolveResult>, import("../../ipfs-http-client/dist/src").HttpOptions>;
        };
        dht: {
            get: (key: string | Uint8Array, options?: (import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => Promise<Uint8Array>;
            put: (key: Uint8Array, value: Uint8Array, options?: (import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => AsyncIterable<import("ipfs-core/src/components/dht").QueryEvent>;
            findProvs: (cid: import("cids"), options?: (import("ipfs-core/src/components/dht").FindProvsOptions & import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => AsyncIterable<import("ipfs-core/src/components/dht").PeerInfo>;
            findPeer: (peerId: import("cids") | import("peer-id"), options?: (import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => Promise<{
                id: string;
                addrs: import("multiaddr")[];
            }>;
            provide: (cids: import("cids") | import("cids")[], options?: (import("ipfs-core/src/components/dht").ProvideOptions & import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => AsyncIterable<import("ipfs-core/src/components/dht").QueryEvent>;
            query: (peerId: string | import("peer-id"), options?: (import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => AsyncIterable<{
                id: import("cids");
                addrs: import("multiaddr")[];
            }>;
        };
        diag: {
            net: (options?: {} | undefined) => Promise<any>;
            sys: (options?: {} | undefined) => Promise<any>;
            cmds: (options?: {} | undefined) => Promise<any>;
        };
        dns: import("../../ipfs-http-client/dist/src/interface").APIWithExtraOptions<(domain: string, options?: (import("ipfs-core/src/components/dns").DNSSettings & import("ipfs-core/src/utils").AbortOptions) | undefined) => Promise<string>, import("../../ipfs-http-client/dist/src").HttpOptions>;
        files: {
            chmod: (path: string, mode: string | number, options?: (import("ipfs-core/src/components/files/chmod").ChmodOptions & import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => Promise<void>;
            cp: (...args: [a1: string | import("cids"), options?: (import("ipfs-core/src/components/files/cp").CpOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined] | [a1: string | import("cids"), a2: string | import("cids"), options?: (import("ipfs-core/src/components/files/cp").CpOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined] | [a1: string | import("cids"), a2: string | import("cids"), a3: string | import("cids"), options?: (import("ipfs-core/src/components/files/cp").CpOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined]) => Promise<void>;
            flush: (path: string, options?: (import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => Promise<import("cids")>;
            ls: (path: string, options?: (import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => AsyncIterable<import("ipfs-core/src/components/files/ls").UnixFSEntry>;
            mkdir: (path: string, options?: (import("ipfs-core/src/components/files/mkdir").MkdirOptions & import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => Promise<void>;
            mv: (...args: [a1: string, a2: string, options?: (import("ipfs-core/src/components/files/mv").MvOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined] | [a1: string, a2: string, a3: string, options?: (import("ipfs-core/src/components/files/mv").MvOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined]) => Promise<void>;
            read: (path: string | import("cids"), options?: (import("ipfs-core/src/components/files/read").ReadOptions & import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => AsyncIterable<Uint8Array>;
            rm: (...args: [a1: string, options?: (import("ipfs-core/src/components/files/rm").RmOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined] | [a1: string, a2: string, options?: (import("ipfs-core/src/components/files/rm").RmOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined] | [a1: string, a2: string, a3: string, options?: (import("ipfs-core/src/components/files/rm").RmOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined]) => Promise<void>;
            stat: (path: string, options?: (import("ipfs-core/src/components/files/stat").StatOptions & import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => Promise<import("ipfs-core/src/components/files/stat").Stat>;
            touch: (path: string, options?: (import("ipfs-core/src/components/files/touch").TouchOptions & import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => Promise<void>;
            write: (path: string, input: string | Uint8Array | AsyncIterable<Uint8Array> | Blob, options?: (import("ipfs-core/src/components/files/write").WriteOptions & import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => Promise<void>;
        };
        get: (path: string | import("cids"), options?: (import("ipfs-core/src/components/get").GetOptions & import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => AsyncIterable<import("ipfs-core/src/utils").File | import("ipfs-core/src/utils").Directory>;
        getEndpointConfig: () => {
            host: string;
            port: string;
            protocol: string;
            pathname: string;
            'api-path': string;
        };
        id: (options?: (import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => Promise<import("ipfs-core/src/components/id").PeerId>;
        key: {
            gen: (name: any, options?: {} | undefined) => Promise<any>;
            list: (options?: {} | undefined) => Promise<any>;
            rename: (oldName: any, newName: any, options?: {} | undefined) => Promise<any>;
            rm: (name: any, options?: {} | undefined) => Promise<any>;
            import: (name: any, pem: any, password: any, options?: {} | undefined) => Promise<any>;
        };
        log: {
            tail: (options?: {} | undefined) => AsyncGenerator<any, void, any>;
            ls: (options?: {} | undefined) => Promise<any>;
            level: (subsystem: any, level: any, options?: {} | undefined) => Promise<any>;
        };
        ls: (path: any, options?: {} | undefined) => AsyncGenerator<{
            name: any;
            path: string;
            size: any;
            cid: import("cids");
            type: string;
            depth: any;
        }, void, unknown>;
        mount: (options?: {} | undefined) => Promise<any>;
        name: {
            publish: (path: any, options?: {} | undefined) => Promise<any>;
            resolve: (path: any, options?: {} | undefined) => AsyncGenerator<any, void, unknown>;
            pubsub: {
                cancel: (name: any, options?: {} | undefined) => Promise<any>;
                state: (options?: {} | undefined) => Promise<any>;
                subs: (options?: {} | undefined) => Promise<any>;
            };
        };
        object: {
            data: (cid: any, options?: {} | undefined) => Promise<Uint8Array>;
            get: (cid: any, options?: {} | undefined) => Promise<any>;
            links: (cid: any, options?: {} | undefined) => Promise<any>;
            new: (options?: {} | undefined) => Promise<import("cids")>;
            patch: {
                addLink: (cid: any, dLink: any, options?: {} | undefined) => Promise<import("cids")>;
                appendData: (cid: any, data: any, options?: {} | undefined) => Promise<import("cids")>;
                rmLink: (cid: any, dLink: any, options?: {} | undefined) => Promise<import("cids")>;
                setData: (cid: any, data: any, options?: {} | undefined) => Promise<import("cids")>;
            };
            put: (obj: any, options?: {} | undefined) => Promise<import("cids")>;
            stat: (cid: any, options?: {} | undefined) => Promise<any>;
        };
        pin: {
            add: (path: any, options?: {} | undefined) => Promise<void | import("cids")>;
            addAll: (source: any, options?: {} | undefined) => AsyncGenerator<import("cids"), void, unknown>;
            ls: (options?: {} | undefined) => AsyncGenerator<{
                type: any;
                cid: import("cids");
            }, void, unknown>;
            rm: (path: any, options?: {} | undefined) => Promise<any>;
            rmAll: (source: any, options?: {} | undefined) => AsyncGenerator<any, void, any>;
        };
        ping: (peerId: any, options?: {} | undefined) => AsyncGenerator<any, void, any>;
        pubsub: {
            ls: (options?: {} | undefined) => Promise<any>;
            peers: (topic: any, options?: {} | undefined) => Promise<any>;
            publish: (topic: any, data: any, options?: {} | undefined) => Promise<void>;
            subscribe: (topic: any, handler: any, options?: {} | undefined) => Promise<any>;
            unsubscribe: (topic: any, handler: any) => Promise<any>;
        };
        refs: {
            (args: any, options?: {} | undefined): AsyncGenerator<any, void, any>;
            local: (options?: {} | undefined) => AsyncGenerator<any, void, any>;
        };
        repo: {
            gc: (options?: {} | undefined) => AsyncGenerator<any, void, any>;
            stat: (options?: {} | undefined) => Promise<{
                numObjects: import("bignumber.js").default;
                repoSize: import("bignumber.js").default;
                repoPath: any;
                version: any;
                storageMax: import("bignumber.js").default;
            }>;
            version: (options?: {} | undefined) => Promise<any>;
        };
        resolve: (path: string, options?: (import("ipfs-core/src/components/resolve").ResolveSettings & import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => Promise<string>;
        stats: {
            bitswap: (options?: (import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => Promise<import("ipfs-core/src/components/bitswap/stat").BitswapStats>;
            bw: (options?: {} | undefined) => AsyncGenerator<any, void, any>;
            repo: (options?: {} | undefined) => Promise<{
                numObjects: import("bignumber.js").default;
                repoSize: import("bignumber.js").default;
                repoPath: any;
                version: any;
                storageMax: import("bignumber.js").default;
            }>;
        };
        stop: (options?: {} | undefined) => Promise<void>;
        shutdown: (options?: {} | undefined) => Promise<void>;
        swarm: {
            addrs: (options?: {} | undefined) => Promise<{
                id: string;
                addrs: any;
            }[]>;
            connect: (addrs: any, options?: {} | undefined) => Promise<any>;
            disconnect: (addrs: any, options?: {} | undefined) => Promise<any>;
            localAddrs: (options?: {} | undefined) => Promise<any>;
            peers: (options?: {} | undefined) => Promise<any>;
        };
        version: (options?: (import("ipfs-core/src/utils").AbortOptions & import("../../ipfs-http-client/dist/src").HttpOptions) | undefined) => Promise<import("ipfs-core/src/components/version").Version>;
    };
    cleanup: () => Promise<void>;
}>;
export function isDaemonOn(): boolean;
export function getRepoPath(): string;
export function disablePrinting(): void;
/**
 *
 * @param {string} msg
 * @param {boolean} [includeNewline=true]
 * @param {boolean} [isError=false]
 */
export function print(msg: string, includeNewline?: boolean | undefined, isError?: boolean | undefined): void;
export namespace print {
    function clearLine(): boolean;
    function cursorTo(pos: any): void;
    function write(data: string | Uint8Array): void;
    function error(msg: string, newline?: boolean | undefined): void;
    const isTTY: boolean;
    const columns: number;
}
export function createProgressBar(totalBytes: any, output: any): any;
export function rightpad(val: any, n: any): string;
export const ipfsPathHelp: string;
export function asBoolean(value: any): any;
export function asOctal(value: any): number;
export function asMtimeFromSeconds(secs: any, nsecs: any): {
    secs: any;
} | undefined;
export function coerceMtime(value: any): any;
export function coerceMtimeNsecs(value: any): any;
/**
 * Strip control characters from a string
 *
 * @param {string} str - a string to strip control characters from
 * @returns {string}
 */
export function stripControlCharacters(str: string): string;
/**
 * Escape control characters in a string
 *
 * @param {string} str - a string to escape control characters in
 * @returns {string}
 */
export function escapeControlCharacters(str: string): string;
/**
 * Removes control characters from all key/values and stringifies
 * CID properties
 *
 * @param {object} obj - all keys/values in this object will be have control characters stripped
 * @param {string} cidBase - any encountered CIDs will be stringified using this base
 * @returns {object}
 */
export function makeEntriesPrintable(obj: object, cidBase?: string): object;
//# sourceMappingURL=utils.d.ts.map